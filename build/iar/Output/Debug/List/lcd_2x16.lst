###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Nov/2016  14:39:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\ilya\vendicont\arm-periphery\Application\lcd_2x16.c
#    Command line =  
#        C:\ilya\vendicont\arm-periphery\Application\lcd_2x16.c -D STM32F10X_HD
#        -D USE_STDPERIPH_DRIVER -D DEBUG=1 -D _FLASH_PROG -lCN
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Debug\List --remarks
#        -o C:\ilya\vendicont\arm-periphery\build\iar\Output\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\ -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\Inc\ -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\library\CMSIS\Include\
#        -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\library\STM32F10x_StdPeriph_Driver\inc\
#        -I C:\ilya\vendicont\arm-periphery\build\iar\..\..\rtos\embos\iar\inc\
#        -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\Application\p-types\
#        -On --use_c++_inline --require_prototypes
#    List file    =  
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Debug\List\lcd_2x16.lst
#    Object file  =  
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Debug\Obj\lcd_2x16.o
#
###############################################################################

C:\ilya\vendicont\arm-periphery\Application\lcd_2x16.c
      1          #include "stm32f10x.h"
      2          #include "RTOS.h"
      3          #include "BSP.h"
      4          #include "lcd_2x16.h"
      5          #include "stm32f10x_gpio.h"
      6          #include "stm32f10x_rcc.h"
      7          

   \                                 In section .bss, align 4
      8          OS_RSEMA SemaLCD;
   \                     SemaLCD:
   \   00000000                      DS8 20
      9          
     10          extern GPIO_InitTypeDef GPIO_InitStructure;

   \                                 In section .bss, align 4
     11          static vu32 TimingDelay;
   \                     TimingDelay:
   \   00000000                      DS8 4
     12          
     13          
     14          //unsigned char lcd_buf[ 32 ];
     15          
     16          /****************************/
     17          /* Strobe 4-Bit Data to LCD */
     18          /****************************/

   \                                 In section .text, align 2, keep-with-next
     19          void lcd_out_data4(unsigned char val)
     20          {
   \                     lcd_out_data4: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     21            if((val&0x01)==0x01)	// Bit[0]
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x07E0             LSLS     R0,R4,#+31
   \   00000008   0xD505             BPL.N    ??lcd_out_data4_0
     22            {
     23              LCD_D4_HI();
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x2108             MOVS     R1,#+8
   \   0000000E   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000010   0x.... 0x....      BL       GPIO_WriteBit
   \   00000014   0xE004             B.N      ??lcd_out_data4_1
     24            }
     25            else
     26            {
     27              LCD_D4_LO();
   \                     ??lcd_out_data4_0: (+1)
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2108             MOVS     R1,#+8
   \   0000001A   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000001C   0x.... 0x....      BL       GPIO_WriteBit
     28            }
     29          
     30            if((val&0x02)==0x02)  // Bit[1]
   \                     ??lcd_out_data4_1: (+1)
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x07A0             LSLS     R0,R4,#+30
   \   00000024   0xD505             BPL.N    ??lcd_out_data4_2
     31            {
     32              LCD_D5_HI();
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000002C   0x.... 0x....      BL       GPIO_WriteBit
   \   00000030   0xE004             B.N      ??lcd_out_data4_3
     33            }
     34            else
     35            {
     36              LCD_D5_LO();
   \                     ??lcd_out_data4_2: (+1)
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2104             MOVS     R1,#+4
   \   00000036   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000038   0x.... 0x....      BL       GPIO_WriteBit
     37            }
     38          
     39            if((val&0x04)==0x04)  // Bit[2]
   \                     ??lcd_out_data4_3: (+1)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x0760             LSLS     R0,R4,#+29
   \   00000040   0xD505             BPL.N    ??lcd_out_data4_4
     40            {
     41              LCD_D6_HI();
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x2102             MOVS     R1,#+2
   \   00000046   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000048   0x.... 0x....      BL       GPIO_WriteBit
   \   0000004C   0xE004             B.N      ??lcd_out_data4_5
     42            }
     43            else
     44            {
     45              LCD_D6_LO();
   \                     ??lcd_out_data4_4: (+1)
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x2102             MOVS     R1,#+2
   \   00000052   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000054   0x.... 0x....      BL       GPIO_WriteBit
     46            }
     47          
     48            if((val&0x08)==0x08)  // Bit[3]
   \                     ??lcd_out_data4_5: (+1)
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x0720             LSLS     R0,R4,#+28
   \   0000005C   0xD505             BPL.N    ??lcd_out_data4_6
     49            {
     50              LCD_D7_HI();
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000064   0x.... 0x....      BL       GPIO_WriteBit
   \   00000068   0xE004             B.N      ??lcd_out_data4_7
     51            }
     52            else
     53            {
     54              LCD_D7_LO();
   \                     ??lcd_out_data4_6: (+1)
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000070   0x.... 0x....      BL       GPIO_WriteBit
     55            }
     56          
     57          }
   \                     ??lcd_out_data4_7: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return
     58          
     59          /****************************/
     60          /* Write Data 1 Byte to LCD */
     61          /****************************/

   \                                 In section .text, align 2, keep-with-next
     62          void lcd_write_byte(unsigned char val)
     63          {
   \                     lcd_write_byte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     64            lcd_out_data4((val>>4)&0x0F);							// Strobe 4-Bit High-Nibble to LCD
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x0900             LSRS     R0,R0,#+4
   \   0000000A   0x.... 0x....      BL       lcd_out_data4
     65            enable_lcd();											// Enable Pulse
   \   0000000E   0x.... 0x....      BL       enable_lcd
     66          
     67            lcd_out_data4(val&0x0F);				  				// Strobe 4-Bit Low-Nibble to LCD
   \   00000012   0xF014 0x000F      ANDS     R0,R4,#0xF
   \   00000016   0x.... 0x....      BL       lcd_out_data4
     68            enable_lcd();											// Enable Pulse
   \   0000001A   0x.... 0x....      BL       enable_lcd
     69          
     70            while(busy_lcd());      								// Wait LCD Execute Complete
   \                     ??lcd_write_byte_0: (+1)
   \   0000001E   0x.... 0x....      BL       busy_lcd
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1FB             BNE.N    ??lcd_write_byte_0
     71          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
     72          
     73          /****************************/
     74          /* Write Instruction to LCD */
     75          /****************************/

   \                                 In section .text, align 2, keep-with-next
     76          void lcd_write_control(unsigned char val)
     77          {
   \                     lcd_write_control: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     78            LCD_RS_LO();											// RS = 0 = Instruction Select
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF44F 0x5180      MOV      R1,#+4096
   \   0000000A   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000000C   0x.... 0x....      BL       GPIO_WriteBit
     79            lcd_write_byte(val);									// Strobe Command Byte
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       lcd_write_byte
     80          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     81          
     82          /****************************/
     83          /* Write Data(ASCII) to LCD */
     84          /****************************/

   \                                 In section .text, align 2, keep-with-next
     85          void lcd_write_ascii(unsigned char c)
     86          {
   \                     lcd_write_ascii: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     87            LCD_RS_HI();											// RS = 1 = Data Select
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF44F 0x5180      MOV      R1,#+4096
   \   0000000A   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000000C   0x.... 0x....      BL       GPIO_WriteBit
     88            lcd_write_byte(c);		   							// Strobe 1 Byte to LCD
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       lcd_write_byte
     89          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     90          
     91          /*******************************/
     92          /* Initial 4-Bit LCD Interface */
     93          /*******************************/

   \                                 In section .text, align 2, keep-with-next
     94          void lcd_init(void)
     95          {
   \                     lcd_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     96            /* Configure IO connected to LCD16X2 */
     97            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_RW, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     98            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x....             LDR.N    R1,??DataTable9_1
   \   0000000E   0x7088             STRB     R0,[R1, #+2]
     99            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000010   0x2010             MOVS     R0,#+16
   \   00000012   0x....             LDR.N    R1,??DataTable9_1
   \   00000014   0x70C8             STRB     R0,[R1, #+3]
    100            GPIO_InitStructure.GPIO_Pin = LCD_EN_PIN;
   \   00000016   0xF44F 0x6080      MOV      R0,#+1024
   \   0000001A   0x....             LDR.N    R1,??DataTable9_1
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
    101            GPIO_Init((GPIO_TypeDef*)GPIOC_BASE, &GPIO_InitStructure);
   \   0000001E   0x....             LDR.N    R1,??DataTable9_1
   \   00000020   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000022   0x.... 0x....      BL       GPIO_Init
    102          
    103          //  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_RW, ENABLE);
    104            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0x....             LDR.N    R1,??DataTable9_1
   \   0000002A   0x7088             STRB     R0,[R1, #+2]
    105            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000002C   0x2010             MOVS     R0,#+16
   \   0000002E   0x....             LDR.N    R1,??DataTable9_1
   \   00000030   0x70C8             STRB     R0,[R1, #+3]
    106            GPIO_InitStructure.GPIO_Pin = LCD_RW_PIN;
   \   00000032   0xF44F 0x6000      MOV      R0,#+2048
   \   00000036   0x....             LDR.N    R1,??DataTable9_1
   \   00000038   0x8008             STRH     R0,[R1, #+0]
    107            GPIO_Init((GPIO_TypeDef*)GPIOC_BASE, &GPIO_InitStructure);
   \   0000003A   0x....             LDR.N    R1,??DataTable9_1
   \   0000003C   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000003E   0x.... 0x....      BL       GPIO_Init
    108          
    109          //  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_RS, ENABLE);
    110            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0x....             LDR.N    R1,??DataTable9_1
   \   00000046   0x7088             STRB     R0,[R1, #+2]
    111            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000048   0x2010             MOVS     R0,#+16
   \   0000004A   0x....             LDR.N    R1,??DataTable9_1
   \   0000004C   0x70C8             STRB     R0,[R1, #+3]
    112            GPIO_InitStructure.GPIO_Pin = LCD_RS_PIN;
   \   0000004E   0xF44F 0x5080      MOV      R0,#+4096
   \   00000052   0x....             LDR.N    R1,??DataTable9_1
   \   00000054   0x8008             STRH     R0,[R1, #+0]
    113            GPIO_Init((GPIO_TypeDef*)GPIOC_BASE, &GPIO_InitStructure);
   \   00000056   0x....             LDR.N    R1,??DataTable9_1
   \   00000058   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000005A   0x.... 0x....      BL       GPIO_Init
    114          
    115          //  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DATA, ENABLE);
    116            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0x....             LDR.N    R1,??DataTable9_1
   \   00000062   0x7088             STRB     R0,[R1, #+2]
    117            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000064   0x2010             MOVS     R0,#+16
   \   00000066   0x....             LDR.N    R1,??DataTable9_1
   \   00000068   0x70C8             STRB     R0,[R1, #+3]
    118            GPIO_InitStructure.GPIO_Pin = LCD_D4_PIN |
    119                                          LCD_D5_PIN |
    120          				LCD_D6_PIN |
    121                                          LCD_D7_PIN;
   \   0000006A   0x200F             MOVS     R0,#+15
   \   0000006C   0x....             LDR.N    R1,??DataTable9_1
   \   0000006E   0x8008             STRH     R0,[R1, #+0]
    122            GPIO_Init((GPIO_TypeDef*)GPIOC_BASE, &GPIO_InitStructure);
   \   00000070   0x....             LDR.N    R1,??DataTable9_1
   \   00000072   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000074   0x.... 0x....      BL       GPIO_Init
    123          
    124            LCD_D4_HI();
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0x2108             MOVS     R1,#+8
   \   0000007C   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000007E   0x.... 0x....      BL       GPIO_WriteBit
    125            LCD_D5_HI();
   \   00000082   0x2201             MOVS     R2,#+1
   \   00000084   0x2104             MOVS     R1,#+4
   \   00000086   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000088   0x.... 0x....      BL       GPIO_WriteBit
    126            LCD_D6_LO();
   \   0000008C   0x2200             MOVS     R2,#+0
   \   0000008E   0x2102             MOVS     R1,#+2
   \   00000090   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000092   0x.... 0x....      BL       GPIO_WriteBit
    127            LCD_D7_LO();
   \   00000096   0x2200             MOVS     R2,#+0
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000009C   0x.... 0x....      BL       GPIO_WriteBit
    128            DelayuS(15000);										// Power-On Delay (15 mS)
   \   000000A0   0xF643 0x2098      MOVW     R0,#+15000
   \   000000A4   0x.... 0x....      BL       DelayuS
    129          
    130            LCD_D4_HI();
   \   000000A8   0x2201             MOVS     R2,#+1
   \   000000AA   0x2108             MOVS     R1,#+8
   \   000000AC   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   000000AE   0x.... 0x....      BL       GPIO_WriteBit
    131            LCD_D5_HI();
   \   000000B2   0x2201             MOVS     R2,#+1
   \   000000B4   0x2104             MOVS     R1,#+4
   \   000000B6   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   000000B8   0x.... 0x....      BL       GPIO_WriteBit
    132            LCD_D6_LO();
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0x2102             MOVS     R1,#+2
   \   000000C0   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   000000C2   0x.... 0x....      BL       GPIO_WriteBit
    133            LCD_D7_LO();
   \   000000C6   0x2200             MOVS     R2,#+0
   \   000000C8   0x2101             MOVS     R1,#+1
   \   000000CA   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   000000CC   0x.... 0x....      BL       GPIO_WriteBit
    134            enable_lcd();											// Enable Pulse
   \   000000D0   0x.... 0x....      BL       enable_lcd
    135            DelayuS(4100);										// Delay 4.1mS
   \   000000D4   0xF241 0x0004      MOVW     R0,#+4100
   \   000000D8   0x.... 0x....      BL       DelayuS
    136          
    137            LCD_D4_HI();
   \   000000DC   0x2201             MOVS     R2,#+1
   \   000000DE   0x2108             MOVS     R1,#+8
   \   000000E0   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   000000E2   0x.... 0x....      BL       GPIO_WriteBit
    138            LCD_D5_HI();
   \   000000E6   0x2201             MOVS     R2,#+1
   \   000000E8   0x2104             MOVS     R1,#+4
   \   000000EA   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   000000EC   0x.... 0x....      BL       GPIO_WriteBit
    139            LCD_D6_LO();
   \   000000F0   0x2200             MOVS     R2,#+0
   \   000000F2   0x2102             MOVS     R1,#+2
   \   000000F4   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   000000F6   0x.... 0x....      BL       GPIO_WriteBit
    140            LCD_D7_LO();
   \   000000FA   0x2200             MOVS     R2,#+0
   \   000000FC   0x2101             MOVS     R1,#+1
   \   000000FE   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000100   0x.... 0x....      BL       GPIO_WriteBit
    141            enable_lcd();											// Enable Pulse
   \   00000104   0x.... 0x....      BL       enable_lcd
    142            DelayuS(100);											// delay 100uS
   \   00000108   0x2064             MOVS     R0,#+100
   \   0000010A   0x.... 0x....      BL       DelayuS
    143          
    144            LCD_D4_HI();
   \   0000010E   0x2201             MOVS     R2,#+1
   \   00000110   0x2108             MOVS     R1,#+8
   \   00000112   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000114   0x.... 0x....      BL       GPIO_WriteBit
    145            LCD_D5_HI();
   \   00000118   0x2201             MOVS     R2,#+1
   \   0000011A   0x2104             MOVS     R1,#+4
   \   0000011C   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000011E   0x.... 0x....      BL       GPIO_WriteBit
    146            LCD_D6_LO();
   \   00000122   0x2200             MOVS     R2,#+0
   \   00000124   0x2102             MOVS     R1,#+2
   \   00000126   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000128   0x.... 0x....      BL       GPIO_WriteBit
    147            LCD_D7_LO();
   \   0000012C   0x2200             MOVS     R2,#+0
   \   0000012E   0x2101             MOVS     R1,#+1
   \   00000130   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000132   0x.... 0x....      BL       GPIO_WriteBit
    148            enable_lcd();											// Enable Pulse
   \   00000136   0x.... 0x....      BL       enable_lcd
    149            //while(busy_lcd());      								// Wait LCD Execute Complete
    150             DelayuS(1000);
   \   0000013A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000013E   0x.... 0x....      BL       DelayuS
    151          
    152            LCD_D4_LO();
   \   00000142   0x2200             MOVS     R2,#+0
   \   00000144   0x2108             MOVS     R1,#+8
   \   00000146   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000148   0x.... 0x....      BL       GPIO_WriteBit
    153            LCD_D5_HI();
   \   0000014C   0x2201             MOVS     R2,#+1
   \   0000014E   0x2104             MOVS     R1,#+4
   \   00000150   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000152   0x.... 0x....      BL       GPIO_WriteBit
    154            LCD_D6_LO();
   \   00000156   0x2200             MOVS     R2,#+0
   \   00000158   0x2102             MOVS     R1,#+2
   \   0000015A   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000015C   0x.... 0x....      BL       GPIO_WriteBit
    155            LCD_D7_LO();
   \   00000160   0x2200             MOVS     R2,#+0
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000166   0x.... 0x....      BL       GPIO_WriteBit
    156            enable_lcd();											// Enable Pulse
   \   0000016A   0x.... 0x....      BL       enable_lcd
    157            //while(busy_lcd());      								// Wait LCD Execute Complete
    158             DelayuS(1000);
   \   0000016E   0xF44F 0x707A      MOV      R0,#+1000
   \   00000172   0x.... 0x....      BL       DelayuS
    159          
    160            lcd_write_control(0x28);  							// Function Set (DL=0 4-Bit,N=1 2 Line,F=0 5X7)
   \   00000176   0x2028             MOVS     R0,#+40
   \   00000178   0x.... 0x....      BL       lcd_write_control
    161            lcd_write_control(0x0C);  							// Display on/off Control (Entry Display,Cursor off,Cursor not Blink)
   \   0000017C   0x200C             MOVS     R0,#+12
   \   0000017E   0x.... 0x....      BL       lcd_write_control
    162            lcd_write_control(0x06);  							// Entry Mode Set (I/D=1 Increment,S=0 Cursor Shift)
   \   00000182   0x2006             MOVS     R0,#+6
   \   00000184   0x.... 0x....      BL       lcd_write_control
    163            lcd_write_control(0x01);  							// Clear Display  (Clear Display,Set DD RAM Address=0)
   \   00000188   0x2001             MOVS     R0,#+1
   \   0000018A   0x.... 0x....      BL       lcd_write_control
    164            //DelaymS(15);  										// Wait Command Ready
    165            //OS_Delay(15);
    166            DelayuS(15000);
   \   0000018E   0xF643 0x2098      MOVW     R0,#+15000
   \   00000192   0x.... 0x....      BL       DelayuS
    167          }
   \   00000196   0xBD01             POP      {R0,PC}          ;; return
    168          
    169          /***************************/
    170          /* Set LCD Position Cursor */
    171          /***************************/

   \                                 In section .text, align 2, keep-with-next
    172          void goto_cursor(unsigned char i)
    173          {
   \                     goto_cursor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    174            i |= 0x80;											// Set DD-RAM Address Command
   \   00000004   0xF054 0x0480      ORRS     R4,R4,#0x80
    175          #if defined (BOOTLOADER)
    176            lcd_write_control(i);
    177          #else
    178            OS_Use( &SemaLCD );
   \   00000008   0x....             LDR.N    R0,??DataTable9_2
   \   0000000A   0x.... 0x....      BL       OS_Use
    179            lcd_write_control(i);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       lcd_write_control
    180            OS_Unuse( &SemaLCD );
   \   00000016   0x....             LDR.N    R0,??DataTable9_2
   \   00000018   0x.... 0x....      BL       OS_Unuse
    181          #endif
    182          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    183          

   \                                 In section .text, align 2, keep-with-next
    184          void lcd_clear() {
   \                     lcd_clear: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    185          #if defined (BOOTLOADER)
    186             lcd_write_control(0x01);	// Clear Display
    187          #else
    188             OS_Use( &SemaLCD );
   \   00000002   0x....             LDR.N    R0,??DataTable9_2
   \   00000004   0x.... 0x....      BL       OS_Use
    189             lcd_write_control(0x01);	// Clear Display
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       lcd_write_control
    190             OS_Unuse( &SemaLCD );
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2
   \   00000010   0x.... 0x....      BL       OS_Unuse
    191          #endif
    192          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    193          
    194          /************************************/
    195          /* Print Display Data(ASCII) to LCD */
    196          /************************************/

   \                                 In section .text, align 2, keep-with-next
    197          void lcd_print( char* str )
    198          {
   \                     lcd_print: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    199            int i;
    200          #if !defined (BOOTLOADER)
    201            OS_Use( &SemaLCD );
   \   00000004   0x....             LDR.N    R0,??DataTable9_2
   \   00000006   0x.... 0x....      BL       OS_Use
    202          #endif
    203            for (i=0;i<16 && str[i]!=0;i++)  						// 16 Character Print
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
   \                     ??lcd_print_0: (+1)
   \   0000000E   0x2D10             CMP      R5,#+16
   \   00000010   0xDA07             BGE.N    ??lcd_print_1
   \   00000012   0x5D28             LDRB     R0,[R5, R4]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??lcd_print_1
    204            {
    205              lcd_write_ascii(str[i]);							// Print Byte to LCD
   \   00000018   0x5D28             LDRB     R0,[R5, R4]
   \   0000001A   0x.... 0x....      BL       lcd_write_ascii
    206            }
   \   0000001E   0x1C6D             ADDS     R5,R5,#+1
   \   00000020   0xE7F5             B.N      ??lcd_print_0
    207             goto_cursor( 0x00 );
   \                     ??lcd_print_1: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       goto_cursor
    208          #if !defined (BOOTLOADER)
    209             OS_Unuse( &SemaLCD );
   \   00000028   0x....             LDR.N    R0,??DataTable9_2
   \   0000002A   0x.... 0x....      BL       OS_Unuse
    210          #endif
    211          }
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    212          
    213          /******************/
    214          /* Wait LCD Ready */
    215          /******************/
    216          

   \                                 In section .text, align 2, keep-with-next
    217          char busy_lcd(void)
    218          {
   \                     busy_lcd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    219          #if !defined (BOOTLOADER)
    220             if ( OS_IsRunning() ) {
   \   00000002   0x....             LDR.N    R0,??DataTable9_3
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD003             BEQ.N    ??busy_lcd_0
    221                OS_Delay (1);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       OS_Delay
   \   00000010   0xE002             B.N      ??busy_lcd_1
    222             } else {
    223                DelayuS(100);
   \                     ??busy_lcd_0: (+1)
   \   00000012   0x2064             MOVS     R0,#+100
   \   00000014   0x.... 0x....      BL       DelayuS
    224             }
    225             IWDG_ReloadCounter();
   \                     ??busy_lcd_1: (+1)
   \   00000018   0x.... 0x....      BL       IWDG_ReloadCounter
    226          #else
    227             DelayuS( 1000 );
    228          #endif
    229             return 0;											// LCD Busy Status
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    230          
    231          #if 0
    232            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		// Config D7 = Read
    233            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    234            GPIO_InitStructure.GPIO_Pin = LCD_D7_PIN;
    235            GPIO_Init((GPIO_TypeDef*)LCD_DATA_PORT, &GPIO_InitStructure);
    236          
    237            LCD_RS_LO();		 									// Instruction Select
    238            LCD_RW_HI(); 											// Read Direction
    239            LCD_EN_HI();											// Start Read Busy
    240          
    241            DelayuS(100);
    242            //OS_Delay (1);
    243            // Delay Before Read
    244            if (GPIO_ReadInputDataBit((GPIO_TypeDef*)LCD_DATA_PORT, LCD_D7_PIN) == Bit_SET)
    245            {
    246              LCD_EN_LO();  										// Disable Read
    247            	LCD_RW_LO();										// Default = Write Direction
    248          
    249          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  	// Config D7 = Write
    250              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    251              GPIO_InitStructure.GPIO_Pin = LCD_D7_PIN;
    252              GPIO_Init((GPIO_TypeDef*)LCD_DATA_PORT, &GPIO_InitStructure);
    253              return 1;											// LCD Busy Status
    254            }
    255            else
    256            {
    257              LCD_EN_LO();  										// Disable Read
    258            	LCD_RW_LO();										// Default = Write Direction
    259          
    260          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	// Config D7 = Write
    261              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    262              GPIO_InitStructure.GPIO_Pin = LCD_D7_PIN;
    263              GPIO_Init((GPIO_TypeDef*)LCD_DATA_PORT, &GPIO_InitStructure);
    264              return 0;											// LCD Ready Status
    265            }
    266          #endif  
    267          }
    268          
    269          
    270          /***********************/
    271          /* Enable Pulse to LCD */
    272          /***********************/

   \                                 In section .text, align 2, keep-with-next
    273          void enable_lcd(void)	 								// Enable Pulse
    274          {
   \                     enable_lcd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    275            LCD_EN_HI();  										// Enable ON
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xF44F 0x6180      MOV      R1,#+1024
   \   00000008   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000000A   0x.... 0x....      BL       GPIO_WriteBit
    276            DelayuS(50);
   \   0000000E   0x2032             MOVS     R0,#+50
   \   00000010   0x.... 0x....      BL       DelayuS
    277            //OS_Delay(1);
    278            LCD_EN_LO();  										// Enable OFF
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF44F 0x6180      MOV      R1,#+1024
   \   0000001A   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   0000001C   0x.... 0x....      BL       GPIO_WriteBit
    279          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    280          
    281          /*******************************************************************************
    282          * Function Name  : Delay
    283          * Description    : Inserts a delay time.
    284          * Input          : nCount: specifies the delay time length.
    285          * Output         : None
    286          * Return         : None
    287          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    288          void DelayuS(vu32 nCount)
    289          {
   \                     DelayuS: (+1)
   \   00000000   0xB401             PUSH     {R0}
    290            while (nCount--);
   \                     ??DelayuS_0: (+1)
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x1E41             SUBS     R1,R0,#+1
   \   00000006   0x9100             STR      R1,[SP, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD1FA             BNE.N    ??DelayuS_0
    291          }
   \   0000000C   0xB001             ADD      SP,SP,#+4
   \   0000000E   0x4770             BX       LR               ;; return
    292          
    293          #if 0
    294          /*******************************************************************************
    295          * Function Name  : Delay
    296          * Description    : Inserts a delay time.
    297          * Input          : nTime: specifies the delay time length, in milliseconds.
    298          * Output         : None
    299          * Return         : None
    300          *******************************************************************************/
    301          void DelaymS(u32 nTime)
    302          {
    303            /* Enable the SysTick Counter */
    304            SysTick_CounterCmd(SysTick_Counter_Enable);
    305          
    306            TimingDelay = nTime;
    307          
    308            while(TimingDelay != 0);
    309          
    310            /* Disable SysTick Counter */
    311            SysTick_CounterCmd(SysTick_Counter_Disable);
    312            /* Clear SysTick Counter */
    313            SysTick_CounterCmd(SysTick_Counter_Clear);
    314          }
    315          #endif
    316          
    317          #if 1
    318          /*******************************************************************************
    319          * Function Name  : TimingDelay_Decrement
    320          * Description    : Decrements the TimingDelay variable.
    321          * Input          : None
    322          * Output         : TimingDelay
    323          * Return         : None
    324          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    325          void TimingDelay_Decrement(void)
    326          {
    327            if (TimingDelay != 0x00)
   \                     TimingDelay_Decrement: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD004             BEQ.N    ??TimingDelay_Decrement_0
    328            {
    329              TimingDelay--;
   \   00000008   0x....             LDR.N    R0,??DataTable9_4
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable9_4
   \   00000010   0x6008             STR      R0,[R1, #+0]
    330            }
    331          }
   \                     ??TimingDelay_Decrement_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     GPIO_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     SemaLCD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     OS_Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     TimingDelay
    332          
    333          #if  0
    334          /*******************************************************************************
    335          * Function Name  : assert_failed
    336          * Description    : Reports the name of the source file and the source line number
    337          *                  where the assert_param error has occurred.
    338          * Input          : - file: pointer to the source file name
    339          *                  - line: assert_param error line source number
    340          * Output         : None
    341          * Return         : None
    342          *******************************************************************************/
    343          void assert_failed(u8* file, u32 line)
    344          {
    345            /* User can add his own implementation to report the file name and line number,
    346               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    347          
    348            /* Infinite loop */
    349            while (1)
    350            {
    351            }
    352          }
    353          #endif
    354          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   DelayuS
       0   TimingDelay_Decrement
       8   busy_lcd
         8   -> DelayuS
         8   -> IWDG_ReloadCounter
         8   -> OS_Delay
       8   enable_lcd
         8   -> DelayuS
         8   -> GPIO_WriteBit
       8   goto_cursor
         8   -> OS_Unuse
         8   -> OS_Use
         8   -> lcd_write_control
       8   lcd_clear
         8   -> OS_Unuse
         8   -> OS_Use
         8   -> lcd_write_control
       8   lcd_init
         8   -> DelayuS
         8   -> GPIO_Init
         8   -> GPIO_WriteBit
         8   -> RCC_APB2PeriphClockCmd
         8   -> enable_lcd
         8   -> lcd_write_control
       8   lcd_out_data4
         8   -> GPIO_WriteBit
      16   lcd_print
        16   -> OS_Unuse
        16   -> OS_Use
        16   -> goto_cursor
        16   -> lcd_write_ascii
       8   lcd_write_ascii
         8   -> GPIO_WriteBit
         8   -> lcd_write_byte
       8   lcd_write_byte
         8   -> busy_lcd
         8   -> enable_lcd
         8   -> lcd_out_data4
       8   lcd_write_control
         8   -> GPIO_WriteBit
         8   -> lcd_write_byte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      16  DelayuS
      20  SemaLCD
       4  TimingDelay
      20  TimingDelay_Decrement
      32  busy_lcd
      34  enable_lcd
      30  goto_cursor
      22  lcd_clear
     408  lcd_init
     118  lcd_out_data4
      48  lcd_print
      26  lcd_write_ascii
      40  lcd_write_byte
      26  lcd_write_control

 
  24 bytes in section .bss
 840 bytes in section .text
 
 840 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none

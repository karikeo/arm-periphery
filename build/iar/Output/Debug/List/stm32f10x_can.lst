###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       09/Nov/2016  14:40:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\ilya\vendicont\arm-periphery\library\STM32F10x_StdPeriph_Driver\src\stm32f10x_can.c
#    Command line =  
#        C:\ilya\vendicont\arm-periphery\library\STM32F10x_StdPeriph_Driver\src\stm32f10x_can.c
#        -D STM32F10X_HD -D USE_STDPERIPH_DRIVER -D DEBUG=1 -D _FLASH_PROG -lCN
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Debug\List --remarks
#        -o C:\ilya\vendicont\arm-periphery\build\iar\Output\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\ -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\Inc\ -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\library\CMSIS\Include\
#        -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\library\STM32F10x_StdPeriph_Driver\inc\
#        -I C:\ilya\vendicont\arm-periphery\build\iar\..\..\rtos\embos\iar\inc\
#        -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\Application\p-types\
#        -On --use_c++_inline --require_prototypes
#    List file    =  
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Debug\List\stm32f10x_can.lst
#    Object file  =  
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Debug\Obj\stm32f10x_can.o
#
###############################################################################

C:\ilya\vendicont\arm-periphery\library\STM32F10x_StdPeriph_Driver\src\stm32f10x_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_can.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the CAN firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_can.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup CAN 
     31            * @brief CAN driver modules
     32            * @{
     33            */ 
     34          
     35          /** @defgroup CAN_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup CAN_Private_Defines
     44            * @{
     45            */
     46          
     47          /* CAN Master Control Register bits */
     48          
     49          #define MCR_DBF      ((uint32_t)0x00010000) /* software master reset */
     50          
     51          /* CAN Mailbox Transmit Request */
     52          #define TMIDxR_TXRQ  ((uint32_t)0x00000001) /* Transmit mailbox request */
     53          
     54          /* CAN Filter Master Register bits */
     55          #define FMR_FINIT    ((uint32_t)0x00000001) /* Filter init mode */
     56          
     57          /* Time out for INAK bit */
     58          #define INAK_TIMEOUT        ((uint32_t)0x0000FFFF)
     59          /* Time out for SLAK bit */
     60          #define SLAK_TIMEOUT        ((uint32_t)0x0000FFFF)
     61          
     62          
     63          
     64          /* Flags in TSR register */
     65          #define CAN_FLAGS_TSR              ((uint32_t)0x08000000) 
     66          /* Flags in RF1R register */
     67          #define CAN_FLAGS_RF1R             ((uint32_t)0x04000000) 
     68          /* Flags in RF0R register */
     69          #define CAN_FLAGS_RF0R             ((uint32_t)0x02000000) 
     70          /* Flags in MSR register */
     71          #define CAN_FLAGS_MSR              ((uint32_t)0x01000000) 
     72          /* Flags in ESR register */
     73          #define CAN_FLAGS_ESR              ((uint32_t)0x00F00000) 
     74          
     75          /* Mailboxes definition */
     76          #define CAN_TXMAILBOX_0                   ((uint8_t)0x00)
     77          #define CAN_TXMAILBOX_1                   ((uint8_t)0x01)
     78          #define CAN_TXMAILBOX_2                   ((uint8_t)0x02) 
     79          
     80          
     81          
     82          #define CAN_MODE_MASK              ((uint32_t) 0x00000003)
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup CAN_Private_Macros
     88            * @{
     89            */
     90          
     91          /**
     92            * @}
     93            */
     94          
     95          /** @defgroup CAN_Private_Variables
     96            * @{
     97            */
     98          
     99          /**
    100            * @}
    101            */
    102          
    103          /** @defgroup CAN_Private_FunctionPrototypes
    104            * @{
    105            */
    106          
    107          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    108          
    109          /**
    110            * @}
    111            */
    112          
    113          /** @defgroup CAN_Private_Functions
    114            * @{
    115            */
    116          
    117          /**
    118            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    119            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    120            * @retval None.
    121            */

   \                                 In section .text, align 2, keep-with-next
    122          void CAN_DeInit(CAN_TypeDef* CANx)
    123          {
   \                     CAN_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    124            /* Check the parameters */
    125            assert_param(IS_CAN_ALL_PERIPH(CANx));
    126           
    127            if (CANx == CAN1)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable6  ;; 0x40006400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD10A             BNE.N    ??CAN_DeInit_0
    128            {
    129              /* Enable CAN1 reset state */
    130              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    131              /* Release CAN1 from reset state */
    132              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF05F 0x7000      MOVS     R0,#+33554432
   \   0000001C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000020   0xE009             B.N      ??CAN_DeInit_1
    133            }
    134            else
    135            {  
    136              /* Enable CAN2 reset state */
    137              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
   \                     ??CAN_DeInit_0: (+1)
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000028   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    138              /* Release CAN2 from reset state */
    139              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000032   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    140            }
    141          }
   \                     ??CAN_DeInit_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    142          
    143          /**
    144            * @brief  Initializes the CAN peripheral according to the specified
    145            *         parameters in the CAN_InitStruct.
    146            * @param  CANx:           where x can be 1 or 2 to to select the CAN 
    147            *                         peripheral.
    148            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
    149            *                         contains the configuration information for the 
    150            *                         CAN peripheral.
    151            * @retval Constant indicates initialization succeed which will be 
    152            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    153            */

   \                                 In section .text, align 2, keep-with-next
    154          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    155          {
   \                     CAN_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    156            uint8_t InitStatus = CAN_InitStatus_Failed;
   \   00000004   0x2000             MOVS     R0,#+0
    157            uint32_t wait_ack = 0x00000000;
   \   00000006   0x2300             MOVS     R3,#+0
    158            /* Check the parameters */
    159            assert_param(IS_CAN_ALL_PERIPH(CANx));
    160            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    161            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    162            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    163            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    164            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    165            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    166            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    167            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    168            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    169            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    170            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    171          
    172            /* Exit from sleep mode */
    173            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
   \   00000008   0x6814             LDR      R4,[R2, #+0]
   \   0000000A   0xF034 0x0402      BICS     R4,R4,#0x2
   \   0000000E   0x6014             STR      R4,[R2, #+0]
    174          
    175            /* Request initialisation */
    176            CANx->MCR |= CAN_MCR_INRQ ;
   \   00000010   0x6814             LDR      R4,[R2, #+0]
   \   00000012   0xF054 0x0401      ORRS     R4,R4,#0x1
   \   00000016   0x6014             STR      R4,[R2, #+0]
    177          
    178            /* Wait the acknowledge */
    179            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
   \                     ??CAN_Init_0: (+1)
   \   00000018   0x6854             LDR      R4,[R2, #+4]
   \   0000001A   0x07E4             LSLS     R4,R4,#+31
   \   0000001C   0xD405             BMI.N    ??CAN_Init_1
   \   0000001E   0xF64F 0x74FF      MOVW     R4,#+65535
   \   00000022   0x42A3             CMP      R3,R4
   \   00000024   0xD001             BEQ.N    ??CAN_Init_1
    180            {
    181              wait_ack++;
   \   00000026   0x1C5B             ADDS     R3,R3,#+1
   \   00000028   0xE7F6             B.N      ??CAN_Init_0
    182            }
    183          
    184            /* Check acknowledge */
    185            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
   \                     ??CAN_Init_1: (+1)
   \   0000002A   0x6854             LDR      R4,[R2, #+4]
   \   0000002C   0x07E4             LSLS     R4,R4,#+31
   \   0000002E   0xD402             BMI.N    ??CAN_Init_2
    186            {
    187              InitStatus = CAN_InitStatus_Failed;
   \   00000030   0x2400             MOVS     R4,#+0
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xE06D             B.N      ??CAN_Init_3
    188            }
    189            else 
    190            {
    191              /* Set the time triggered communication mode */
    192              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \                     ??CAN_Init_2: (+1)
   \   00000036   0x798C             LDRB     R4,[R1, #+6]
   \   00000038   0x2C01             CMP      R4,#+1
   \   0000003A   0xD104             BNE.N    ??CAN_Init_4
    193              {
    194                CANx->MCR |= CAN_MCR_TTCM;
   \   0000003C   0x6814             LDR      R4,[R2, #+0]
   \   0000003E   0xF054 0x0480      ORRS     R4,R4,#0x80
   \   00000042   0x6014             STR      R4,[R2, #+0]
   \   00000044   0xE003             B.N      ??CAN_Init_5
    195              }
    196              else
    197              {
    198                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
   \                     ??CAN_Init_4: (+1)
   \   00000046   0x6814             LDR      R4,[R2, #+0]
   \   00000048   0xF034 0x0480      BICS     R4,R4,#0x80
   \   0000004C   0x6014             STR      R4,[R2, #+0]
    199              }
    200          
    201              /* Set the automatic bus-off management */
    202              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_5: (+1)
   \   0000004E   0x79CC             LDRB     R4,[R1, #+7]
   \   00000050   0x2C01             CMP      R4,#+1
   \   00000052   0xD104             BNE.N    ??CAN_Init_6
    203              {
    204                CANx->MCR |= CAN_MCR_ABOM;
   \   00000054   0x6814             LDR      R4,[R2, #+0]
   \   00000056   0xF054 0x0440      ORRS     R4,R4,#0x40
   \   0000005A   0x6014             STR      R4,[R2, #+0]
   \   0000005C   0xE003             B.N      ??CAN_Init_7
    205              }
    206              else
    207              {
    208                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
   \                     ??CAN_Init_6: (+1)
   \   0000005E   0x6814             LDR      R4,[R2, #+0]
   \   00000060   0xF034 0x0440      BICS     R4,R4,#0x40
   \   00000064   0x6014             STR      R4,[R2, #+0]
    209              }
    210          
    211              /* Set the automatic wake-up mode */
    212              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_7: (+1)
   \   00000066   0x7A0C             LDRB     R4,[R1, #+8]
   \   00000068   0x2C01             CMP      R4,#+1
   \   0000006A   0xD104             BNE.N    ??CAN_Init_8
    213              {
    214                CANx->MCR |= CAN_MCR_AWUM;
   \   0000006C   0x6814             LDR      R4,[R2, #+0]
   \   0000006E   0xF054 0x0420      ORRS     R4,R4,#0x20
   \   00000072   0x6014             STR      R4,[R2, #+0]
   \   00000074   0xE003             B.N      ??CAN_Init_9
    215              }
    216              else
    217              {
    218                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
   \                     ??CAN_Init_8: (+1)
   \   00000076   0x6814             LDR      R4,[R2, #+0]
   \   00000078   0xF034 0x0420      BICS     R4,R4,#0x20
   \   0000007C   0x6014             STR      R4,[R2, #+0]
    219              }
    220          
    221              /* Set the no automatic retransmission */
    222              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_9: (+1)
   \   0000007E   0x7A4C             LDRB     R4,[R1, #+9]
   \   00000080   0x2C01             CMP      R4,#+1
   \   00000082   0xD104             BNE.N    ??CAN_Init_10
    223              {
    224                CANx->MCR |= CAN_MCR_NART;
   \   00000084   0x6814             LDR      R4,[R2, #+0]
   \   00000086   0xF054 0x0410      ORRS     R4,R4,#0x10
   \   0000008A   0x6014             STR      R4,[R2, #+0]
   \   0000008C   0xE003             B.N      ??CAN_Init_11
    225              }
    226              else
    227              {
    228                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
   \                     ??CAN_Init_10: (+1)
   \   0000008E   0x6814             LDR      R4,[R2, #+0]
   \   00000090   0xF034 0x0410      BICS     R4,R4,#0x10
   \   00000094   0x6014             STR      R4,[R2, #+0]
    229              }
    230          
    231              /* Set the receive FIFO locked mode */
    232              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_11: (+1)
   \   00000096   0x7A8C             LDRB     R4,[R1, #+10]
   \   00000098   0x2C01             CMP      R4,#+1
   \   0000009A   0xD104             BNE.N    ??CAN_Init_12
    233              {
    234                CANx->MCR |= CAN_MCR_RFLM;
   \   0000009C   0x6814             LDR      R4,[R2, #+0]
   \   0000009E   0xF054 0x0408      ORRS     R4,R4,#0x8
   \   000000A2   0x6014             STR      R4,[R2, #+0]
   \   000000A4   0xE003             B.N      ??CAN_Init_13
    235              }
    236              else
    237              {
    238                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
   \                     ??CAN_Init_12: (+1)
   \   000000A6   0x6814             LDR      R4,[R2, #+0]
   \   000000A8   0xF034 0x0408      BICS     R4,R4,#0x8
   \   000000AC   0x6014             STR      R4,[R2, #+0]
    239              }
    240          
    241              /* Set the transmit FIFO priority */
    242              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_13: (+1)
   \   000000AE   0x7ACC             LDRB     R4,[R1, #+11]
   \   000000B0   0x2C01             CMP      R4,#+1
   \   000000B2   0xD104             BNE.N    ??CAN_Init_14
    243              {
    244                CANx->MCR |= CAN_MCR_TXFP;
   \   000000B4   0x6814             LDR      R4,[R2, #+0]
   \   000000B6   0xF054 0x0404      ORRS     R4,R4,#0x4
   \   000000BA   0x6014             STR      R4,[R2, #+0]
   \   000000BC   0xE003             B.N      ??CAN_Init_15
    245              }
    246              else
    247              {
    248                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
   \                     ??CAN_Init_14: (+1)
   \   000000BE   0x6814             LDR      R4,[R2, #+0]
   \   000000C0   0xF034 0x0404      BICS     R4,R4,#0x4
   \   000000C4   0x6014             STR      R4,[R2, #+0]
    249              }
    250          
    251              /* Set the bit timing register */
    252              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    253                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    254                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    255                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    256                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_15: (+1)
   \   000000C6   0x788C             LDRB     R4,[R1, #+2]
   \   000000C8   0x78CD             LDRB     R5,[R1, #+3]
   \   000000CA   0x062D             LSLS     R5,R5,#+24
   \   000000CC   0xEA55 0x7484      ORRS     R4,R5,R4, LSL #+30
   \   000000D0   0x790D             LDRB     R5,[R1, #+4]
   \   000000D2   0xEA54 0x4405      ORRS     R4,R4,R5, LSL #+16
   \   000000D6   0x794D             LDRB     R5,[R1, #+5]
   \   000000D8   0xEA54 0x5405      ORRS     R4,R4,R5, LSL #+20
   \   000000DC   0x880D             LDRH     R5,[R1, #+0]
   \   000000DE   0x1E6D             SUBS     R5,R5,#+1
   \   000000E0   0x432C             ORRS     R4,R5,R4
   \   000000E2   0x61D4             STR      R4,[R2, #+28]
    257          
    258              /* Request leave initialisation */
    259              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
   \   000000E4   0x6814             LDR      R4,[R2, #+0]
   \   000000E6   0x0864             LSRS     R4,R4,#+1
   \   000000E8   0x0064             LSLS     R4,R4,#+1
   \   000000EA   0x6014             STR      R4,[R2, #+0]
    260          
    261             /* Wait the acknowledge */
    262             wait_ack = 0;
   \   000000EC   0x2400             MOVS     R4,#+0
   \   000000EE   0x0023             MOVS     R3,R4
    263          
    264             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
   \                     ??CAN_Init_16: (+1)
   \   000000F0   0x6854             LDR      R4,[R2, #+4]
   \   000000F2   0x07E4             LSLS     R4,R4,#+31
   \   000000F4   0xD505             BPL.N    ??CAN_Init_17
   \   000000F6   0xF64F 0x74FF      MOVW     R4,#+65535
   \   000000FA   0x42A3             CMP      R3,R4
   \   000000FC   0xD001             BEQ.N    ??CAN_Init_17
    265             {
    266               wait_ack++;
   \   000000FE   0x1C5B             ADDS     R3,R3,#+1
   \   00000100   0xE7F6             B.N      ??CAN_Init_16
    267             }
    268          
    269              /* ...and check acknowledged */
    270              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
   \                     ??CAN_Init_17: (+1)
   \   00000102   0x6854             LDR      R4,[R2, #+4]
   \   00000104   0x07E4             LSLS     R4,R4,#+31
   \   00000106   0xD502             BPL.N    ??CAN_Init_18
    271              {
    272                InitStatus = CAN_InitStatus_Failed;
   \   00000108   0x2400             MOVS     R4,#+0
   \   0000010A   0x0020             MOVS     R0,R4
   \   0000010C   0xE001             B.N      ??CAN_Init_3
    273              }
    274              else
    275              {
    276                InitStatus = CAN_InitStatus_Success ;
   \                     ??CAN_Init_18: (+1)
   \   0000010E   0x2401             MOVS     R4,#+1
   \   00000110   0x0020             MOVS     R0,R4
    277              }
    278            }
    279          
    280            /* At this step, return the status of initialization */
    281            return InitStatus;
   \                     ??CAN_Init_3: (+1)
   \   00000112   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000114   0xBC30             POP      {R4,R5}
   \   00000116   0x4770             BX       LR               ;; return
    282          }
    283          
    284          /**
    285            * @brief  Initializes the CAN peripheral according to the specified
    286            *         parameters in the CAN_FilterInitStruct.
    287            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
    288            *                               structure that contains the configuration 
    289            *                               information.
    290            * @retval None.
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    293          {
   \                     CAN_FilterInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
    294            uint32_t filter_number_bit_pos = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    295            /* Check the parameters */
    296            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    297            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    298            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    299            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    300            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    301          
    302            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x7A83             LDRB     R3,[R0, #+10]
   \   00000008   0x409A             LSLS     R2,R2,R3
   \   0000000A   0x0011             MOVS     R1,R2
    303          
    304            /* Initialisation mode for the filter */
    305            CAN1->FMR |= FMR_FINIT;
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000016   0x.... 0x....      LDR.W    R3,??DataTable6_1  ;; 0x40006600
   \   0000001A   0x601A             STR      R2,[R3, #+0]
    306          
    307            /* Filter Deactivation */
    308            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable6_2  ;; 0x4000661c
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x438A             BICS     R2,R2,R1
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable6_2  ;; 0x4000661c
   \   00000028   0x601A             STR      R2,[R3, #+0]
    309          
    310            /* Filter Scale */
    311            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   0000002A   0x7B02             LDRB     R2,[R0, #+12]
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD119             BNE.N    ??CAN_FilterInit_0
    312            {
    313              /* 16-bit scale for the filter */
    314              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable6_3  ;; 0x4000660c
   \   00000034   0x6812             LDR      R2,[R2, #+0]
   \   00000036   0x438A             BICS     R2,R2,R1
   \   00000038   0x.... 0x....      LDR.W    R3,??DataTable6_3  ;; 0x4000660c
   \   0000003C   0x601A             STR      R2,[R3, #+0]
    315          
    316              /* First 16-bit identifier and First 16-bit mask */
    317              /* Or First 16-bit identifier and Second 16-bit identifier */
    318              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    319              ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    320                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   0000003E   0x88C2             LDRH     R2,[R0, #+6]
   \   00000040   0x8843             LDRH     R3,[R0, #+2]
   \   00000042   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   00000046   0x.... 0x....      LDR.W    R3,??DataTable6_4  ;; 0x40006640
   \   0000004A   0x7A84             LDRB     R4,[R0, #+10]
   \   0000004C   0xF843 0x2034      STR      R2,[R3, R4, LSL #+3]
    321          
    322              /* Second 16-bit identifier and Second 16-bit mask */
    323              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    324              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    325              ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    326                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable6_4  ;; 0x40006640
   \   00000054   0x7A83             LDRB     R3,[R0, #+10]
   \   00000056   0xEB12 0x02C3      ADDS     R2,R2,R3, LSL #+3
   \   0000005A   0x8883             LDRH     R3,[R0, #+4]
   \   0000005C   0x8804             LDRH     R4,[R0, #+0]
   \   0000005E   0xEA54 0x4303      ORRS     R3,R4,R3, LSL #+16
   \   00000062   0x6053             STR      R3,[R2, #+4]
    327            }
    328          
    329            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_0: (+1)
   \   00000064   0x7B02             LDRB     R2,[R0, #+12]
   \   00000066   0x2A01             CMP      R2,#+1
   \   00000068   0xD119             BNE.N    ??CAN_FilterInit_1
    330            {
    331              /* 32-bit scale for the filter */
    332              CAN1->FS1R |= filter_number_bit_pos;
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable6_3  ;; 0x4000660c
   \   0000006E   0x6812             LDR      R2,[R2, #+0]
   \   00000070   0x430A             ORRS     R2,R1,R2
   \   00000072   0x.... 0x....      LDR.W    R3,??DataTable6_3  ;; 0x4000660c
   \   00000076   0x601A             STR      R2,[R3, #+0]
    333              /* 32-bit identifier or First 32-bit identifier */
    334              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    335              ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    336                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000078   0x8802             LDRH     R2,[R0, #+0]
   \   0000007A   0x8843             LDRH     R3,[R0, #+2]
   \   0000007C   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   00000080   0x.... 0x....      LDR.W    R3,??DataTable6_4  ;; 0x40006640
   \   00000084   0x7A84             LDRB     R4,[R0, #+10]
   \   00000086   0xF843 0x2034      STR      R2,[R3, R4, LSL #+3]
    337              /* 32-bit mask or Second 32-bit identifier */
    338              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    339              ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    340                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable6_4  ;; 0x40006640
   \   0000008E   0x7A83             LDRB     R3,[R0, #+10]
   \   00000090   0xEB12 0x02C3      ADDS     R2,R2,R3, LSL #+3
   \   00000094   0x8883             LDRH     R3,[R0, #+4]
   \   00000096   0x88C4             LDRH     R4,[R0, #+6]
   \   00000098   0xEA54 0x4303      ORRS     R3,R4,R3, LSL #+16
   \   0000009C   0x6053             STR      R3,[R2, #+4]
    341            }
    342          
    343            /* Filter Mode */
    344            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_1: (+1)
   \   0000009E   0x7AC2             LDRB     R2,[R0, #+11]
   \   000000A0   0x2A00             CMP      R2,#+0
   \   000000A2   0xD107             BNE.N    ??CAN_FilterInit_2
    345            {
    346              /*Id/Mask mode for the filter*/
    347              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable6_5  ;; 0x40006604
   \   000000A8   0x6812             LDR      R2,[R2, #+0]
   \   000000AA   0x438A             BICS     R2,R2,R1
   \   000000AC   0x.... 0x....      LDR.W    R3,??DataTable6_5  ;; 0x40006604
   \   000000B0   0x601A             STR      R2,[R3, #+0]
   \   000000B2   0xE006             B.N      ??CAN_FilterInit_3
    348            }
    349            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    350            {
    351              /*Identifier list mode for the filter*/
    352              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
   \                     ??CAN_FilterInit_2: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R2,??DataTable6_5  ;; 0x40006604
   \   000000B8   0x6812             LDR      R2,[R2, #+0]
   \   000000BA   0x430A             ORRS     R2,R1,R2
   \   000000BC   0x.... 0x....      LDR.W    R3,??DataTable6_5  ;; 0x40006604
   \   000000C0   0x601A             STR      R2,[R3, #+0]
    353            }
    354          
    355            /* Filter FIFO assignment */
    356            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
   \                     ??CAN_FilterInit_3: (+1)
   \   000000C2   0x8902             LDRH     R2,[R0, #+8]
   \   000000C4   0x2A00             CMP      R2,#+0
   \   000000C6   0xD106             BNE.N    ??CAN_FilterInit_4
    357            {
    358              /* FIFO 0 assignation for the filter */
    359              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
   \   000000C8   0x.... 0x....      LDR.W    R2,??DataTable6_6  ;; 0x40006614
   \   000000CC   0x6812             LDR      R2,[R2, #+0]
   \   000000CE   0x438A             BICS     R2,R2,R1
   \   000000D0   0x.... 0x....      LDR.W    R3,??DataTable6_6  ;; 0x40006614
   \   000000D4   0x601A             STR      R2,[R3, #+0]
    360            }
    361          
    362            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
   \                     ??CAN_FilterInit_4: (+1)
   \   000000D6   0x8902             LDRH     R2,[R0, #+8]
   \   000000D8   0x2A01             CMP      R2,#+1
   \   000000DA   0xD106             BNE.N    ??CAN_FilterInit_5
    363            {
    364              /* FIFO 1 assignation for the filter */
    365              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
   \   000000DC   0x.... 0x....      LDR.W    R2,??DataTable6_6  ;; 0x40006614
   \   000000E0   0x6812             LDR      R2,[R2, #+0]
   \   000000E2   0x430A             ORRS     R2,R1,R2
   \   000000E4   0x.... 0x....      LDR.W    R3,??DataTable6_6  ;; 0x40006614
   \   000000E8   0x601A             STR      R2,[R3, #+0]
    366            }
    367            
    368            /* Filter activation */
    369            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_5: (+1)
   \   000000EA   0x7B42             LDRB     R2,[R0, #+13]
   \   000000EC   0x2A01             CMP      R2,#+1
   \   000000EE   0xD106             BNE.N    ??CAN_FilterInit_6
    370            {
    371              CAN1->FA1R |= filter_number_bit_pos;
   \   000000F0   0x.... 0x....      LDR.W    R2,??DataTable6_2  ;; 0x4000661c
   \   000000F4   0x6812             LDR      R2,[R2, #+0]
   \   000000F6   0x430A             ORRS     R2,R1,R2
   \   000000F8   0x.... 0x....      LDR.W    R3,??DataTable6_2  ;; 0x4000661c
   \   000000FC   0x601A             STR      R2,[R3, #+0]
    372            }
    373          
    374            /* Leave the initialisation mode for the filter */
    375            CAN1->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_6: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   00000102   0x6812             LDR      R2,[R2, #+0]
   \   00000104   0x0852             LSRS     R2,R2,#+1
   \   00000106   0x0052             LSLS     R2,R2,#+1
   \   00000108   0x.... 0x....      LDR.W    R3,??DataTable6_1  ;; 0x40006600
   \   0000010C   0x601A             STR      R2,[R3, #+0]
    376          }
   \   0000010E   0xBC10             POP      {R4}
   \   00000110   0x4770             BX       LR               ;; return
    377          
    378          /**
    379            * @brief  Fills each CAN_InitStruct member with its default value.
    380            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
    381            *                         will be initialized.
    382            * @retval None.
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    385          {
    386            /* Reset CAN init structure parameters values */
    387            
    388            /* Initialize the time triggered communication mode */
    389            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7181             STRB     R1,[R0, #+6]
    390            
    391            /* Initialize the automatic bus-off management */
    392            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x71C1             STRB     R1,[R0, #+7]
    393            
    394            /* Initialize the automatic wake-up mode */
    395            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7201             STRB     R1,[R0, #+8]
    396            
    397            /* Initialize the no automatic retransmission */
    398            CAN_InitStruct->CAN_NART = DISABLE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7241             STRB     R1,[R0, #+9]
    399            
    400            /* Initialize the receive FIFO locked mode */
    401            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7281             STRB     R1,[R0, #+10]
    402            
    403            /* Initialize the transmit FIFO priority */
    404            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x72C1             STRB     R1,[R0, #+11]
    405            
    406            /* Initialize the CAN_Mode member */
    407            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7081             STRB     R1,[R0, #+2]
    408            
    409            /* Initialize the CAN_SJW member */
    410            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x70C1             STRB     R1,[R0, #+3]
    411            
    412            /* Initialize the CAN_BS1 member */
    413            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x7101             STRB     R1,[R0, #+4]
    414            
    415            /* Initialize the CAN_BS2 member */
    416            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x7141             STRB     R1,[R0, #+5]
    417            
    418            /* Initialize the CAN_Prescaler member */
    419            CAN_InitStruct->CAN_Prescaler = 1;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x8001             STRH     R1,[R0, #+0]
    420          }
   \   0000002C   0x4770             BX       LR               ;; return
    421          
    422          /**
    423            * @brief  Select the start bank filter for slave CAN.
    424            * @note   This function applies only to STM32 Connectivity line devices.
    425            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    426            * @retval None.
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    429          {
    430            /* Check the parameters */
    431            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    432            
    433            /* Enter Initialisation mode for the filter */
    434            CAN1->FMR |= FMR_FINIT;
   \                     CAN_SlaveStartBank: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    435            
    436            /* Select the start slave bank */
    437            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable6_7  ;; 0xffffc0f1
   \   0000001A   0x4011             ANDS     R1,R2,R1
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   00000020   0x6011             STR      R1,[R2, #+0]
    438            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xEA51 0x2100      ORRS     R1,R1,R0, LSL #+8
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   00000032   0x6011             STR      R1,[R2, #+0]
    439            
    440            /* Leave Initialisation mode for the filter */
    441            CAN1->FMR &= ~FMR_FINIT;
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x0849             LSRS     R1,R1,#+1
   \   0000003C   0x0049             LSLS     R1,R1,#+1
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   00000042   0x6011             STR      R1,[R2, #+0]
    442          }
   \   00000044   0x4770             BX       LR               ;; return
    443          
    444          /**
    445            * @brief  Enables or disables the DBG Freeze for CAN.
    446            * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
    447            * @param  NewState: new state of the CAN peripheral. This parameter can 
    448            *                   be: ENABLE or DISABLE.
    449            * @retval None.
    450            */

   \                                 In section .text, align 2, keep-with-next
    451          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    452          {
    453            /* Check the parameters */
    454            assert_param(IS_CAN_ALL_PERIPH(CANx));
    455            assert_param(IS_FUNCTIONAL_STATE(NewState));
    456            
    457            if (NewState != DISABLE)
   \                     CAN_DBGFreeze: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??CAN_DBGFreeze_0
    458            {
    459              /* Enable Debug Freeze  */
    460              CANx->MCR |= MCR_DBF;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0xF452 0x3280      ORRS     R2,R2,#0x10000
   \   0000000C   0x6002             STR      R2,[R0, #+0]
   \   0000000E   0xE003             B.N      ??CAN_DBGFreeze_1
    461            }
    462            else
    463            {
    464              /* Disable Debug Freeze */
    465              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_0: (+1)
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0xF432 0x3280      BICS     R2,R2,#0x10000
   \   00000016   0x6002             STR      R2,[R0, #+0]
    466            }
    467          }
   \                     ??CAN_DBGFreeze_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    468          
    469          
    470          /**
    471            * @brief  Enables or disabes the CAN Time TriggerOperation communication mode.
    472            * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
    473            * @param  NewState : Mode new state , can be one of @ref FunctionalState.
    474            * @note   when enabled, Time stamp (TIME[15:0]) value is sent in the last 
    475            *         two data bytes of the 8-byte message: TIME[7:0] in data byte 6 
    476            *         and TIME[15:8] in data byte 7 
    477            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    478            *         sent over the CAN bus.  
    479            * @retval None
    480            */

   \                                 In section .text, align 2, keep-with-next
    481          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    482          {
    483            /* Check the parameters */
    484            assert_param(IS_CAN_ALL_PERIPH(CANx));
    485            assert_param(IS_FUNCTIONAL_STATE(NewState));
    486            if (NewState != DISABLE)
   \                     CAN_TTComModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD016             BEQ.N    ??CAN_TTComModeCmd_0
    487            {
    488              /* Enable the TTCM mode */
    489              CANx->MCR |= CAN_MCR_TTCM;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    490          
    491              /* Set TGT bits */
    492              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
   \   0000000E   0xF8D0 0x2184      LDR      R2,[R0, #+388]
   \   00000012   0xF452 0x7280      ORRS     R2,R2,#0x100
   \   00000016   0xF8C0 0x2184      STR      R2,[R0, #+388]
    493              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
   \   0000001A   0xF8D0 0x2194      LDR      R2,[R0, #+404]
   \   0000001E   0xF452 0x7280      ORRS     R2,R2,#0x100
   \   00000022   0xF8C0 0x2194      STR      R2,[R0, #+404]
    494              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
   \   00000026   0xF8D0 0x21A4      LDR      R2,[R0, #+420]
   \   0000002A   0xF452 0x7280      ORRS     R2,R2,#0x100
   \   0000002E   0xF8C0 0x21A4      STR      R2,[R0, #+420]
   \   00000032   0xE015             B.N      ??CAN_TTComModeCmd_1
    495            }
    496            else
    497            {
    498              /* Disable the TTCM mode */
    499              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
   \                     ??CAN_TTComModeCmd_0: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0xF032 0x0280      BICS     R2,R2,#0x80
   \   0000003A   0x6002             STR      R2,[R0, #+0]
    500          
    501              /* Reset TGT bits */
    502              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
   \   0000003C   0xF8D0 0x2184      LDR      R2,[R0, #+388]
   \   00000040   0xF432 0x7280      BICS     R2,R2,#0x100
   \   00000044   0xF8C0 0x2184      STR      R2,[R0, #+388]
    503              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
   \   00000048   0xF8D0 0x2194      LDR      R2,[R0, #+404]
   \   0000004C   0xF432 0x7280      BICS     R2,R2,#0x100
   \   00000050   0xF8C0 0x2194      STR      R2,[R0, #+404]
    504              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
   \   00000054   0xF8D0 0x21A4      LDR      R2,[R0, #+420]
   \   00000058   0xF432 0x7280      BICS     R2,R2,#0x100
   \   0000005C   0xF8C0 0x21A4      STR      R2,[R0, #+420]
    505            }
    506          }
   \                     ??CAN_TTComModeCmd_1: (+1)
   \   00000060   0x4770             BX       LR               ;; return
    507          /**
    508            * @brief  Initiates the transmission of a message.
    509            * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
    510            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN
    511            *                    DLC and CAN data.
    512            * @retval The number of the mailbox that is used for transmission
    513            *                    or CAN_TxStatus_NoMailBox if there is no empty mailbox.
    514            */

   \                                 In section .text, align 2, keep-with-next
    515          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    516          {
   \                     CAN_Transmit: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    517            uint8_t transmit_mailbox = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    518            /* Check the parameters */
    519            assert_param(IS_CAN_ALL_PERIPH(CANx));
    520            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    521            assert_param(IS_CAN_RTR(TxMessage->RTR));
    522            assert_param(IS_CAN_DLC(TxMessage->DLC));
    523          
    524            /* Select one empty transmit mailbox */
    525            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
   \   00000006   0x6893             LDR      R3,[R2, #+8]
   \   00000008   0x015B             LSLS     R3,R3,#+5
   \   0000000A   0xD502             BPL.N    ??CAN_Transmit_0
    526            {
    527              transmit_mailbox = 0;
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xE00D             B.N      ??CAN_Transmit_1
    528            }
    529            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
   \                     ??CAN_Transmit_0: (+1)
   \   00000012   0x6893             LDR      R3,[R2, #+8]
   \   00000014   0x011B             LSLS     R3,R3,#+4
   \   00000016   0xD502             BPL.N    ??CAN_Transmit_2
    530            {
    531              transmit_mailbox = 1;
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x0018             MOVS     R0,R3
   \   0000001C   0xE007             B.N      ??CAN_Transmit_1
    532            }
    533            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
   \                     ??CAN_Transmit_2: (+1)
   \   0000001E   0x6893             LDR      R3,[R2, #+8]
   \   00000020   0x00DB             LSLS     R3,R3,#+3
   \   00000022   0xD502             BPL.N    ??CAN_Transmit_3
    534            {
    535              transmit_mailbox = 2;
   \   00000024   0x2302             MOVS     R3,#+2
   \   00000026   0x0018             MOVS     R0,R3
   \   00000028   0xE001             B.N      ??CAN_Transmit_1
    536            }
    537            else
    538            {
    539              transmit_mailbox = CAN_TxStatus_NoMailBox;
   \                     ??CAN_Transmit_3: (+1)
   \   0000002A   0x2304             MOVS     R3,#+4
   \   0000002C   0x0018             MOVS     R0,R3
    540            }
    541          
    542            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
   \                     ??CAN_Transmit_1: (+1)
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x2804             CMP      R0,#+4
   \   00000032   0xD075             BEQ.N    ??CAN_Transmit_4
    543            {
    544              /* Set up the Id */
    545              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   0000003A   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   0000003E   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   00000048   0xF8C4 0x3180      STR      R3,[R4, #+384]
    546              if (TxMessage->IDE == CAN_Id_Standard)
   \   0000004C   0x7A0B             LDRB     R3,[R1, #+8]
   \   0000004E   0x2B00             CMP      R3,#+0
   \   00000050   0xD10F             BNE.N    ??CAN_Transmit_5
    547              {
    548                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    549                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    550                                                            TxMessage->RTR);
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   00000058   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   0000005C   0x680C             LDR      R4,[R1, #+0]
   \   0000005E   0x7A4D             LDRB     R5,[R1, #+9]
   \   00000060   0xEA55 0x5444      ORRS     R4,R5,R4, LSL #+21
   \   00000064   0x4323             ORRS     R3,R4,R3
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   0000006C   0xF8C4 0x3180      STR      R3,[R4, #+384]
   \   00000070   0xE010             B.N      ??CAN_Transmit_6
    551              }
    552              else
    553              {
    554                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    555                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    556                                                            TxMessage->IDE | \
    557                                                            TxMessage->RTR);
   \                     ??CAN_Transmit_5: (+1)
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   00000078   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   0000007C   0x684C             LDR      R4,[R1, #+4]
   \   0000007E   0x7A0D             LDRB     R5,[R1, #+8]
   \   00000080   0xEA55 0x04C4      ORRS     R4,R5,R4, LSL #+3
   \   00000084   0x7A4D             LDRB     R5,[R1, #+9]
   \   00000086   0x432C             ORRS     R4,R5,R4
   \   00000088   0x4323             ORRS     R3,R4,R3
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   00000090   0xF8C4 0x3180      STR      R3,[R4, #+384]
    558              }
    559              
    560              /* Set up the DLC */
    561              TxMessage->DLC &= (uint8_t)0x0000000F;
   \                     ??CAN_Transmit_6: (+1)
   \   00000094   0x7A8B             LDRB     R3,[R1, #+10]
   \   00000096   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   0000009A   0x728B             STRB     R3,[R1, #+10]
    562              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   000000A2   0xF8D3 0x3184      LDR      R3,[R3, #+388]
   \   000000A6   0x091B             LSRS     R3,R3,#+4
   \   000000A8   0x011B             LSLS     R3,R3,#+4
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   000000B0   0xF8C4 0x3184      STR      R3,[R4, #+388]
    563              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   000000BA   0xF8D3 0x3184      LDR      R3,[R3, #+388]
   \   000000BE   0x7A8C             LDRB     R4,[R1, #+10]
   \   000000C0   0x4323             ORRS     R3,R4,R3
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   000000C8   0xF8C4 0x3184      STR      R3,[R4, #+388]
    564          
    565              /* Set up the data field */
    566              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    567                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    568                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    569                                                       ((uint32_t)TxMessage->Data[0]));
   \   000000CC   0x7B8B             LDRB     R3,[R1, #+14]
   \   000000CE   0x7B4C             LDRB     R4,[R1, #+13]
   \   000000D0   0x0424             LSLS     R4,R4,#+16
   \   000000D2   0xEA54 0x6303      ORRS     R3,R4,R3, LSL #+24
   \   000000D6   0x7B0C             LDRB     R4,[R1, #+12]
   \   000000D8   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   000000DC   0x7ACC             LDRB     R4,[R1, #+11]
   \   000000DE   0x4323             ORRS     R3,R4,R3
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   000000E6   0xF8C4 0x3188      STR      R3,[R4, #+392]
    570              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    571                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    572                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    573                                                       ((uint32_t)TxMessage->Data[4]));
   \   000000EA   0x7C8B             LDRB     R3,[R1, #+18]
   \   000000EC   0x7C4C             LDRB     R4,[R1, #+17]
   \   000000EE   0x0424             LSLS     R4,R4,#+16
   \   000000F0   0xEA54 0x6303      ORRS     R3,R4,R3, LSL #+24
   \   000000F4   0x7C0C             LDRB     R4,[R1, #+16]
   \   000000F6   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   000000FA   0x7BCC             LDRB     R4,[R1, #+15]
   \   000000FC   0x4323             ORRS     R3,R4,R3
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   00000104   0xF8C4 0x318C      STR      R3,[R4, #+396]
    574              /* Request transmission */
    575              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
   \   00000108   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010A   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   0000010E   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   00000112   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000118   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   0000011C   0xF8C4 0x3180      STR      R3,[R4, #+384]
    576            }
    577            return transmit_mailbox;
   \                     ??CAN_Transmit_4: (+1)
   \   00000120   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000122   0xBC30             POP      {R4,R5}
   \   00000124   0x4770             BX       LR               ;; return
    578          }
    579          
    580          /**
    581            * @brief  Checks the transmission of a message.
    582            * @param  CANx:            where x can be 1 or 2 to to select the 
    583            *                          CAN peripheral.
    584            * @param  TransmitMailbox: the number of the mailbox that is used for 
    585            *                          transmission.
    586            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, CAN_TxStatus_Failed 
    587            *         in an other case.
    588            */

   \                                 In section .text, align 2, keep-with-next
    589          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    590          {
   \                     CAN_TransmitStatus: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    591            uint32_t state = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    592          
    593            /* Check the parameters */
    594            assert_param(IS_CAN_ALL_PERIPH(CANx));
    595            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    596           
    597            switch (TransmitMailbox)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD003             BEQ.N    ??CAN_TransmitStatus_0
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD00D             BEQ.N    ??CAN_TransmitStatus_1
   \   00000010   0xD306             BCC.N    ??CAN_TransmitStatus_2
   \   00000012   0xE011             B.N      ??CAN_TransmitStatus_3
    598            {
    599              case (CAN_TXMAILBOX_0): 
    600                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
   \                     ??CAN_TransmitStatus_0: (+1)
   \   00000014   0x6893             LDR      R3,[R2, #+8]
   \   00000016   0x.... 0x....      LDR.W    R4,??DataTable6_8  ;; 0x4000003
   \   0000001A   0x4023             ANDS     R3,R4,R3
   \   0000001C   0x0018             MOVS     R0,R3
    601                break;
   \   0000001E   0xE00D             B.N      ??CAN_TransmitStatus_4
    602              case (CAN_TXMAILBOX_1): 
    603                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
   \                     ??CAN_TransmitStatus_2: (+1)
   \   00000020   0x6893             LDR      R3,[R2, #+8]
   \   00000022   0x.... 0x....      LDR.W    R4,??DataTable6_9  ;; 0x8000300
   \   00000026   0x4023             ANDS     R3,R4,R3
   \   00000028   0x0018             MOVS     R0,R3
    604                break;
   \   0000002A   0xE007             B.N      ??CAN_TransmitStatus_4
    605              case (CAN_TXMAILBOX_2): 
    606                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
   \                     ??CAN_TransmitStatus_1: (+1)
   \   0000002C   0x6893             LDR      R3,[R2, #+8]
   \   0000002E   0x.... 0x....      LDR.W    R4,??DataTable6_10  ;; 0x10030000
   \   00000032   0x4023             ANDS     R3,R4,R3
   \   00000034   0x0018             MOVS     R0,R3
    607                break;
   \   00000036   0xE001             B.N      ??CAN_TransmitStatus_4
    608              default:
    609                state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_3: (+1)
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x0018             MOVS     R0,R3
    610                break;
    611            }
    612            switch (state)
   \                     ??CAN_TransmitStatus_4: (+1)
   \   0000003C   0x0003             MOVS     R3,R0
   \   0000003E   0x2B00             CMP      R3,#+0
   \   00000040   0xD016             BEQ.N    ??CAN_TransmitStatus_5
   \   00000042   0x.... 0x....      LDR.W    R4,??DataTable6_11  ;; 0x4000001
   \   00000046   0x1B1B             SUBS     R3,R3,R4
   \   00000048   0xD015             BEQ.N    ??CAN_TransmitStatus_6
   \   0000004A   0x1E9B             SUBS     R3,R3,#+2
   \   0000004C   0xD01C             BEQ.N    ??CAN_TransmitStatus_7
   \   0000004E   0x.... 0x....      LDR.W    R4,??DataTable6_12  ;; 0x40000fd
   \   00000052   0x1B1B             SUBS     R3,R3,R4
   \   00000054   0xD012             BEQ.N    ??CAN_TransmitStatus_8
   \   00000056   0xF44F 0x7400      MOV      R4,#+512
   \   0000005A   0x1B1B             SUBS     R3,R3,R4
   \   0000005C   0xD017             BEQ.N    ??CAN_TransmitStatus_9
   \   0000005E   0x.... 0x....      LDR.W    R4,??DataTable6_13  ;; 0x800fd00
   \   00000062   0x1B1B             SUBS     R3,R3,R4
   \   00000064   0xD00D             BEQ.N    ??CAN_TransmitStatus_10
   \   00000066   0xF45F 0x3400      MOVS     R4,#+131072
   \   0000006A   0x1B1B             SUBS     R3,R3,R4
   \   0000006C   0xD012             BEQ.N    ??CAN_TransmitStatus_11
   \   0000006E   0xE014             B.N      ??CAN_TransmitStatus_12
    613            {
    614                /* transmit pending  */
    615              case (0x0): state = CAN_TxStatus_Pending;
   \                     ??CAN_TransmitStatus_5: (+1)
   \   00000070   0x2302             MOVS     R3,#+2
   \   00000072   0x0018             MOVS     R0,R3
    616                break;
   \   00000074   0xE013             B.N      ??CAN_TransmitStatus_13
    617                /* transmit failed  */
    618               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_6: (+1)
   \   00000076   0x2300             MOVS     R3,#+0
   \   00000078   0x0018             MOVS     R0,R3
    619                break;
   \   0000007A   0xE010             B.N      ??CAN_TransmitStatus_13
    620               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_8: (+1)
   \   0000007C   0x2300             MOVS     R3,#+0
   \   0000007E   0x0018             MOVS     R0,R3
    621                break;
   \   00000080   0xE00D             B.N      ??CAN_TransmitStatus_13
    622               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_10: (+1)
   \   00000082   0x2300             MOVS     R3,#+0
   \   00000084   0x0018             MOVS     R0,R3
    623                break;
   \   00000086   0xE00A             B.N      ??CAN_TransmitStatus_13
    624                /* transmit succeeded  */
    625              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_7: (+1)
   \   00000088   0x2301             MOVS     R3,#+1
   \   0000008A   0x0018             MOVS     R0,R3
    626                break;
   \   0000008C   0xE007             B.N      ??CAN_TransmitStatus_13
    627              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_9: (+1)
   \   0000008E   0x2301             MOVS     R3,#+1
   \   00000090   0x0018             MOVS     R0,R3
    628                break;
   \   00000092   0xE004             B.N      ??CAN_TransmitStatus_13
    629              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_11: (+1)
   \   00000094   0x2301             MOVS     R3,#+1
   \   00000096   0x0018             MOVS     R0,R3
    630                break;
   \   00000098   0xE001             B.N      ??CAN_TransmitStatus_13
    631              default: state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_12: (+1)
   \   0000009A   0x2300             MOVS     R3,#+0
   \   0000009C   0x0018             MOVS     R0,R3
    632                break;
    633            }
    634            return (uint8_t) state;
   \                     ??CAN_TransmitStatus_13: (+1)
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0xBC10             POP      {R4}
   \   000000A2   0x4770             BX       LR               ;; return
    635          }
    636          
    637          /**
    638            * @brief  Cancels a transmit request.
    639            * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral. 
    640            * @param  Mailbox:  Mailbox number.
    641            * @retval None.
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    644          {
    645            /* Check the parameters */
    646            assert_param(IS_CAN_ALL_PERIPH(CANx));
    647            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    648            /* abort transmission */
    649            switch (Mailbox)
   \                     CAN_CancelTransmit: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_CancelTransmit_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD00B             BEQ.N    ??CAN_CancelTransmit_1
   \   0000000A   0xD305             BCC.N    ??CAN_CancelTransmit_2
   \   0000000C   0xE00E             B.N      ??CAN_CancelTransmit_3
    650            {
    651              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0: (+1)
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000014   0x6082             STR      R2,[R0, #+8]
    652                break;
   \   00000016   0xE009             B.N      ??CAN_CancelTransmit_4
    653              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_2: (+1)
   \   00000018   0x6882             LDR      R2,[R0, #+8]
   \   0000001A   0xF452 0x4200      ORRS     R2,R2,#0x8000
   \   0000001E   0x6082             STR      R2,[R0, #+8]
    654                break;
   \   00000020   0xE004             B.N      ??CAN_CancelTransmit_4
    655              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_1: (+1)
   \   00000022   0x6882             LDR      R2,[R0, #+8]
   \   00000024   0xF452 0x0200      ORRS     R2,R2,#0x800000
   \   00000028   0x6082             STR      R2,[R0, #+8]
    656                break;
   \   0000002A   0xE7FF             B.N      ??CAN_CancelTransmit_4
    657              default:
    658                break;
    659            }
    660          }
   \                     ??CAN_CancelTransmit_3: (+1)
   \                     ??CAN_CancelTransmit_4: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    661          
    662          
    663          /**
    664            * @brief  Receives a message.
    665            * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
    666            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    667            * @param  RxMessage:  pointer to a structure receive message which contains 
    668            *                     CAN Id, CAN DLC, CAN datas and FMI number.
    669            * @retval None.
    670            */

   \                                 In section .text, align 2, keep-with-next
    671          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    672          {
    673            /* Check the parameters */
    674            assert_param(IS_CAN_ALL_PERIPH(CANx));
    675            assert_param(IS_CAN_FIFO(FIFONumber));
    676            /* Get the Id */
    677            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     CAN_Receive: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000006   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   0000000A   0xF013 0x0304      ANDS     R3,R3,#0x4
   \   0000000E   0x7213             STRB     R3,[R2, #+8]
    678            if (RxMessage->IDE == CAN_Id_Standard)
   \   00000010   0x7A13             LDRB     R3,[R2, #+8]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD107             BNE.N    ??CAN_Receive_0
    679            {
    680              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000001C   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   00000020   0x0D5B             LSRS     R3,R3,#+21
   \   00000022   0x6013             STR      R3,[R2, #+0]
   \   00000024   0xE006             B.N      ??CAN_Receive_1
    681            }
    682            else
    683            {
    684              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_0: (+1)
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000002C   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   00000030   0x08DB             LSRS     R3,R3,#+3
   \   00000032   0x6053             STR      R3,[R2, #+4]
    685            }
    686            
    687            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1: (+1)
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000003A   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   0000003E   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   00000042   0x7253             STRB     R3,[R2, #+9]
    688            /* Get the DLC */
    689            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000004A   0xF8D3 0x31B4      LDR      R3,[R3, #+436]
   \   0000004E   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   00000052   0x7293             STRB     R3,[R2, #+10]
    690            /* Get the FMI */
    691            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000005A   0xF8D3 0x31B4      LDR      R3,[R3, #+436]
   \   0000005E   0x0A1B             LSRS     R3,R3,#+8
   \   00000060   0x74D3             STRB     R3,[R2, #+19]
    692            /* Get the data field */
    693            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000068   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   0000006C   0x72D3             STRB     R3,[R2, #+11]
    694            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000074   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   00000078   0x0A1B             LSRS     R3,R3,#+8
   \   0000007A   0x7313             STRB     R3,[R2, #+12]
    695            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000082   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   00000086   0x0C1B             LSRS     R3,R3,#+16
   \   00000088   0x7353             STRB     R3,[R2, #+13]
    696            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000090   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   00000094   0x0E1B             LSRS     R3,R3,#+24
   \   00000096   0x7393             STRB     R3,[R2, #+14]
    697            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   00000098   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000009E   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000A2   0x73D3             STRB     R3,[R2, #+15]
    698            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   000000A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A6   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   000000AA   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000AE   0x0A1B             LSRS     R3,R3,#+8
   \   000000B0   0x7413             STRB     R3,[R2, #+16]
    699            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   000000B2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B4   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   000000B8   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000BC   0x0C1B             LSRS     R3,R3,#+16
   \   000000BE   0x7453             STRB     R3,[R2, #+17]
    700            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   000000C0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C2   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   000000C6   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000CA   0x0E1B             LSRS     R3,R3,#+24
   \   000000CC   0x7493             STRB     R3,[R2, #+18]
    701            /* Release the FIFO */
    702            /* Release FIFO0 */
    703            if (FIFONumber == CAN_FIFO0)
   \   000000CE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D0   0x2900             CMP      R1,#+0
   \   000000D2   0xD104             BNE.N    ??CAN_Receive_2
    704            {
    705              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   000000D4   0x68C3             LDR      R3,[R0, #+12]
   \   000000D6   0xF053 0x0320      ORRS     R3,R3,#0x20
   \   000000DA   0x60C3             STR      R3,[R0, #+12]
   \   000000DC   0xE003             B.N      ??CAN_Receive_3
    706            }
    707            /* Release FIFO1 */
    708            else /* FIFONumber == CAN_FIFO1 */
    709            {
    710              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_Receive_2: (+1)
   \   000000DE   0x6903             LDR      R3,[R0, #+16]
   \   000000E0   0xF053 0x0320      ORRS     R3,R3,#0x20
   \   000000E4   0x6103             STR      R3,[R0, #+16]
    711            }
    712          }
   \                     ??CAN_Receive_3: (+1)
   \   000000E6   0x4770             BX       LR               ;; return
    713          
    714          /**
    715            * @brief  Releases the specified FIFO.
    716            * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral. 
    717            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    718            * @retval None.
    719            */

   \                                 In section .text, align 2, keep-with-next
    720          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    721          {
    722            /* Check the parameters */
    723            assert_param(IS_CAN_ALL_PERIPH(CANx));
    724            assert_param(IS_CAN_FIFO(FIFONumber));
    725            /* Release FIFO0 */
    726            if (FIFONumber == CAN_FIFO0)
   \                     CAN_FIFORelease: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD104             BNE.N    ??CAN_FIFORelease_0
    727            {
    728              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   0000000C   0x60C2             STR      R2,[R0, #+12]
   \   0000000E   0xE003             B.N      ??CAN_FIFORelease_1
    729            }
    730            /* Release FIFO1 */
    731            else /* FIFONumber == CAN_FIFO1 */
    732            {
    733              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0: (+1)
   \   00000010   0x6902             LDR      R2,[R0, #+16]
   \   00000012   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   00000016   0x6102             STR      R2,[R0, #+16]
    734            }
    735          }
   \                     ??CAN_FIFORelease_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    736          
    737          /**
    738            * @brief  Returns the number of pending messages.
    739            * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
    740            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    741            * @retval NbMessage : which is the number of pending message.
    742            */

   \                                 In section .text, align 2, keep-with-next
    743          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    744          {
   \                     CAN_MessagePending: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    745            uint8_t message_pending=0;
   \   00000002   0x2000             MOVS     R0,#+0
    746            /* Check the parameters */
    747            assert_param(IS_CAN_ALL_PERIPH(CANx));
    748            assert_param(IS_CAN_FIFO(FIFONumber));
    749            if (FIFONumber == CAN_FIFO0)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD104             BNE.N    ??CAN_MessagePending_0
    750            {
    751              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
   \   0000000A   0x68D3             LDR      R3,[R2, #+12]
   \   0000000C   0xF013 0x0303      ANDS     R3,R3,#0x3
   \   00000010   0x0018             MOVS     R0,R3
   \   00000012   0xE009             B.N      ??CAN_MessagePending_1
    752            }
    753            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0: (+1)
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD104             BNE.N    ??CAN_MessagePending_2
    754            {
    755              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
   \   0000001A   0x6913             LDR      R3,[R2, #+16]
   \   0000001C   0xF013 0x0303      ANDS     R3,R3,#0x3
   \   00000020   0x0018             MOVS     R0,R3
   \   00000022   0xE001             B.N      ??CAN_MessagePending_1
    756            }
    757            else
    758            {
    759              message_pending = 0;
   \                     ??CAN_MessagePending_2: (+1)
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x0018             MOVS     R0,R3
    760            }
    761            return message_pending;
   \                     ??CAN_MessagePending_1: (+1)
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4770             BX       LR               ;; return
    762          }
    763          
    764          
    765          /**
    766            * @brief   Select the CAN Operation mode.
    767            * @param CAN_OperatingMode : CAN Operating Mode. This parameter can be one 
    768            *                            of @ref CAN_OperatingMode_TypeDef enumeration.
    769            * @retval status of the requested mode which can be 
    770            *         - CAN_ModeStatus_Failed    CAN failed entering the specific mode 
    771            *         - CAN_ModeStatus_Success   CAN Succeed entering the specific mode 
    772          
    773            */

   \                                 In section .text, align 2, keep-with-next
    774          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    775          {
   \                     CAN_OperatingModeRequest: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    776            uint8_t status = CAN_ModeStatus_Failed;
   \   00000004   0x2000             MOVS     R0,#+0
    777            
    778            /* Timeout for INAK or also for SLAK bits*/
    779            uint32_t timeout = INAK_TIMEOUT; 
   \   00000006   0xF64F 0x73FF      MOVW     R3,#+65535
    780          
    781            /* Check the parameters */
    782            assert_param(IS_CAN_ALL_PERIPH(CANx));
    783            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    784          
    785            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD119             BNE.N    ??CAN_OperatingModeRequest_0
    786            {
    787              /* Request initialisation */
    788              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
   \   00000010   0x6814             LDR      R4,[R2, #+0]
   \   00000012   0xF034 0x0402      BICS     R4,R4,#0x2
   \   00000016   0xF054 0x0401      ORRS     R4,R4,#0x1
   \   0000001A   0x6014             STR      R4,[R2, #+0]
    789          
    790              /* Wait the acknowledge */
    791              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
   \                     ??CAN_OperatingModeRequest_1: (+1)
   \   0000001C   0x6854             LDR      R4,[R2, #+4]
   \   0000001E   0xF014 0x0403      ANDS     R4,R4,#0x3
   \   00000022   0x2C01             CMP      R4,#+1
   \   00000024   0xD003             BEQ.N    ??CAN_OperatingModeRequest_2
   \   00000026   0x2B00             CMP      R3,#+0
   \   00000028   0xD001             BEQ.N    ??CAN_OperatingModeRequest_2
    792              {
    793                timeout--;
   \   0000002A   0x1E5B             SUBS     R3,R3,#+1
   \   0000002C   0xE7F6             B.N      ??CAN_OperatingModeRequest_1
    794              }
    795              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
   \                     ??CAN_OperatingModeRequest_2: (+1)
   \   0000002E   0x6854             LDR      R4,[R2, #+4]
   \   00000030   0xF014 0x0403      ANDS     R4,R4,#0x3
   \   00000034   0x2C01             CMP      R4,#+1
   \   00000036   0xD002             BEQ.N    ??CAN_OperatingModeRequest_3
    796              {
    797                status = CAN_ModeStatus_Failed;
   \   00000038   0x2400             MOVS     R4,#+0
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xE03A             B.N      ??CAN_OperatingModeRequest_4
    798              }
    799              else
    800              {
    801                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_3: (+1)
   \   0000003E   0x2401             MOVS     R4,#+1
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xE037             B.N      ??CAN_OperatingModeRequest_4
    802              }
    803            }
    804            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
   \                     ??CAN_OperatingModeRequest_0: (+1)
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x2901             CMP      R1,#+1
   \   00000048   0xD115             BNE.N    ??CAN_OperatingModeRequest_5
    805            {
    806              /* Request leave initialisation and sleep mode  and enter Normal mode */
    807              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
   \   0000004A   0x6814             LDR      R4,[R2, #+0]
   \   0000004C   0x08A4             LSRS     R4,R4,#+2
   \   0000004E   0x00A4             LSLS     R4,R4,#+2
   \   00000050   0x6014             STR      R4,[R2, #+0]
    808          
    809              /* Wait the acknowledge */
    810              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
   \                     ??CAN_OperatingModeRequest_6: (+1)
   \   00000052   0x6854             LDR      R4,[R2, #+4]
   \   00000054   0xF014 0x0F03      TST      R4,#0x3
   \   00000058   0xD003             BEQ.N    ??CAN_OperatingModeRequest_7
   \   0000005A   0x2B00             CMP      R3,#+0
   \   0000005C   0xD001             BEQ.N    ??CAN_OperatingModeRequest_7
    811              {
    812                timeout--;
   \   0000005E   0x1E5B             SUBS     R3,R3,#+1
   \   00000060   0xE7F7             B.N      ??CAN_OperatingModeRequest_6
    813              }
    814              if ((CANx->MSR & CAN_MODE_MASK) != 0)
   \                     ??CAN_OperatingModeRequest_7: (+1)
   \   00000062   0x6854             LDR      R4,[R2, #+4]
   \   00000064   0xF014 0x0F03      TST      R4,#0x3
   \   00000068   0xD002             BEQ.N    ??CAN_OperatingModeRequest_8
    815              {
    816                status = CAN_ModeStatus_Failed;
   \   0000006A   0x2400             MOVS     R4,#+0
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0xE021             B.N      ??CAN_OperatingModeRequest_4
    817              }
    818              else
    819              {
    820                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_8: (+1)
   \   00000070   0x2401             MOVS     R4,#+1
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0xE01E             B.N      ??CAN_OperatingModeRequest_4
    821              }
    822            }
    823            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
   \                     ??CAN_OperatingModeRequest_5: (+1)
   \   00000076   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000078   0x2902             CMP      R1,#+2
   \   0000007A   0xD119             BNE.N    ??CAN_OperatingModeRequest_9
    824            {
    825              /* Request Sleep mode */
    826              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   0000007C   0x6814             LDR      R4,[R2, #+0]
   \   0000007E   0x0864             LSRS     R4,R4,#+1
   \   00000080   0x0064             LSLS     R4,R4,#+1
   \   00000082   0xF054 0x0402      ORRS     R4,R4,#0x2
   \   00000086   0x6014             STR      R4,[R2, #+0]
    827          
    828              /* Wait the acknowledge */
    829              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
   \                     ??CAN_OperatingModeRequest_10: (+1)
   \   00000088   0x6854             LDR      R4,[R2, #+4]
   \   0000008A   0xF014 0x0403      ANDS     R4,R4,#0x3
   \   0000008E   0x2C02             CMP      R4,#+2
   \   00000090   0xD003             BEQ.N    ??CAN_OperatingModeRequest_11
   \   00000092   0x2B00             CMP      R3,#+0
   \   00000094   0xD001             BEQ.N    ??CAN_OperatingModeRequest_11
    830              {
    831                timeout--;
   \   00000096   0x1E5B             SUBS     R3,R3,#+1
   \   00000098   0xE7F6             B.N      ??CAN_OperatingModeRequest_10
    832              }
    833              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
   \                     ??CAN_OperatingModeRequest_11: (+1)
   \   0000009A   0x6854             LDR      R4,[R2, #+4]
   \   0000009C   0xF014 0x0403      ANDS     R4,R4,#0x3
   \   000000A0   0x2C02             CMP      R4,#+2
   \   000000A2   0xD002             BEQ.N    ??CAN_OperatingModeRequest_12
    834              {
    835                status = CAN_ModeStatus_Failed;
   \   000000A4   0x2400             MOVS     R4,#+0
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0xE004             B.N      ??CAN_OperatingModeRequest_4
    836              }
    837              else
    838              {
    839                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_12: (+1)
   \   000000AA   0x2401             MOVS     R4,#+1
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0xE001             B.N      ??CAN_OperatingModeRequest_4
    840              }
    841            }
    842            else
    843            {
    844              status = CAN_ModeStatus_Failed;
   \                     ??CAN_OperatingModeRequest_9: (+1)
   \   000000B0   0x2400             MOVS     R4,#+0
   \   000000B2   0x0020             MOVS     R0,R4
    845            }
    846          
    847            return  (uint8_t) status;
   \                     ??CAN_OperatingModeRequest_4: (+1)
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xBC10             POP      {R4}
   \   000000B8   0x4770             BX       LR               ;; return
    848          }
    849          
    850          /**
    851            * @brief  Enters the low power mode.
    852            * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
    853            * @retval status: CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed in an 
    854            *                 other case.
    855            */

   \                                 In section .text, align 2, keep-with-next
    856          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    857          {
   \                     CAN_Sleep: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    858            uint8_t sleepstatus = CAN_Sleep_Failed;
   \   00000002   0x2000             MOVS     R0,#+0
    859            
    860            /* Check the parameters */
    861            assert_param(IS_CAN_ALL_PERIPH(CANx));
    862              
    863            /* Request Sleep mode */
    864             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    865             
    866            /* Sleep mode status */
    867            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   00000016   0x2A02             CMP      R2,#+2
   \   00000018   0xD101             BNE.N    ??CAN_Sleep_0
    868            {
    869              /* Sleep mode not entered */
    870              sleepstatus =  CAN_Sleep_Ok;
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x0010             MOVS     R0,R2
    871            }
    872            /* return sleep mode status */
    873             return (uint8_t)sleepstatus;
   \                     ??CAN_Sleep_0: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x4770             BX       LR               ;; return
    874          }
    875          
    876          /**
    877            * @brief  Wakes the CAN up.
    878            * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
    879            * @retval status:  CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed in an 
    880            *                  other case.
    881            */

   \                                 In section .text, align 2, keep-with-next
    882          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    883          {
   \                     CAN_WakeUp: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    884            uint32_t wait_slak = SLAK_TIMEOUT;
   \   00000002   0xF64F 0x72FF      MOVW     R2,#+65535
    885            uint8_t wakeupstatus = CAN_WakeUp_Failed;
   \   00000006   0x2000             MOVS     R0,#+0
    886            
    887            /* Check the parameters */
    888            assert_param(IS_CAN_ALL_PERIPH(CANx));
    889              
    890            /* Wake up request */
    891            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
   \   00000008   0x680B             LDR      R3,[R1, #+0]
   \   0000000A   0xF033 0x0302      BICS     R3,R3,#0x2
   \   0000000E   0x600B             STR      R3,[R1, #+0]
    892              
    893            /* Sleep mode status */
    894            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
   \                     ??CAN_WakeUp_0: (+1)
   \   00000010   0x684B             LDR      R3,[R1, #+4]
   \   00000012   0x079B             LSLS     R3,R3,#+30
   \   00000014   0xD503             BPL.N    ??CAN_WakeUp_1
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD001             BEQ.N    ??CAN_WakeUp_1
    895            {
    896             wait_slak--;
   \   0000001A   0x1E52             SUBS     R2,R2,#+1
   \   0000001C   0xE7F8             B.N      ??CAN_WakeUp_0
    897            }
    898            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_1: (+1)
   \   0000001E   0x684B             LDR      R3,[R1, #+4]
   \   00000020   0x079B             LSLS     R3,R3,#+30
   \   00000022   0xD401             BMI.N    ??CAN_WakeUp_2
    899            {
    900             /* wake up done : Sleep mode exited */
    901              wakeupstatus = CAN_WakeUp_Ok;
   \   00000024   0x2301             MOVS     R3,#+1
   \   00000026   0x0018             MOVS     R0,R3
    902            }
    903            /* return wakeup status */
    904            return (uint8_t)wakeupstatus;
   \                     ??CAN_WakeUp_2: (+1)
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4770             BX       LR               ;; return
    905          }
    906          
    907          
    908          /**
    909            * @brief  Returns the CANx's last error code (LEC).
    910            * @param  CANx:          where x can be 1 or 2 to to select the CAN peripheral.  
    911            * @retval CAN_ErrorCode: specifies the Error code : 
    912            *                        - CAN_ERRORCODE_NoErr            No Error  
    913            *                        - CAN_ERRORCODE_StuffErr         Stuff Error
    914            *                        - CAN_ERRORCODE_FormErr          Form Error
    915            *                        - CAN_ERRORCODE_ACKErr           Acknowledgment Error
    916            *                        - CAN_ERRORCODE_BitRecessiveErr  Bit Recessive Error
    917            *                        - CAN_ERRORCODE_BitDominantErr   Bit Dominant Error
    918            *                        - CAN_ERRORCODE_CRCErr           CRC Error
    919            *                        - CAN_ERRORCODE_SoftwareSetErr   Software Set Error  
    920            */
    921           

   \                                 In section .text, align 2, keep-with-next
    922          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
    923          {
   \                     CAN_GetLastErrorCode: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    924            uint8_t errorcode=0;
   \   00000002   0x2000             MOVS     R0,#+0
    925            
    926            /* Check the parameters */
    927            assert_param(IS_CAN_ALL_PERIPH(CANx));
    928            
    929            /* Get the error code*/
    930            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   \   00000004   0x698A             LDR      R2,[R1, #+24]
   \   00000006   0xF012 0x0270      ANDS     R2,R2,#0x70
   \   0000000A   0x0010             MOVS     R0,R2
    931            
    932            /* Return the error code*/
    933            return errorcode;
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
    934          }
    935          /**
    936            * @brief  Returns the CANx Receive Error Counter (REC).
    937            * @note   In case of an error during reception, this counter is incremented 
    938            *         by 1 or by 8 depending on the error condition as defined by the CAN 
    939            *         standard. After every successful reception, the counter is 
    940            *         decremented by 1 or reset to 120 if its value was higher than 128. 
    941            *         When the counter value exceeds 127, the CAN controller enters the 
    942            *         error passive state.  
    943            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
    944            * @retval CAN Receive Error Counter. 
    945            */

   \                                 In section .text, align 2, keep-with-next
    946          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
    947          {
   \                     CAN_GetReceiveErrorCounter: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    948            uint8_t counter=0;
   \   00000002   0x2000             MOVS     R0,#+0
    949            
    950            /* Check the parameters */
    951            assert_param(IS_CAN_ALL_PERIPH(CANx));
    952            
    953            /* Get the Receive Error Counter*/
    954            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   \   00000004   0x698A             LDR      R2,[R1, #+24]
   \   00000006   0x0E12             LSRS     R2,R2,#+24
   \   00000008   0x0010             MOVS     R0,R2
    955            
    956            /* Return the Receive Error Counter*/
    957            return counter;
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x4770             BX       LR               ;; return
    958          }
    959          
    960          
    961          /**
    962            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
    963            * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.  
    964            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
    965            */

   \                                 In section .text, align 2, keep-with-next
    966          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
    967          {
   \                     CAN_GetLSBTransmitErrorCounter: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    968            uint8_t counter=0;
   \   00000002   0x2000             MOVS     R0,#+0
    969            
    970            /* Check the parameters */
    971            assert_param(IS_CAN_ALL_PERIPH(CANx));
    972            
    973            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
    974            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   \   00000004   0x698A             LDR      R2,[R1, #+24]
   \   00000006   0x0C12             LSRS     R2,R2,#+16
   \   00000008   0x0010             MOVS     R0,R2
    975            
    976            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
    977            return counter;
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x4770             BX       LR               ;; return
    978          }
    979          
    980          
    981          /**
    982            * @brief  Enables or disables the specified CANx interrupts.
    983            * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
    984            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
    985            *                 This parameter can be: 
    986            *                 - CAN_IT_TME, 
    987            *                 - CAN_IT_FMP0, 
    988            *                 - CAN_IT_FF0,
    989            *                 - CAN_IT_FOV0, 
    990            *                 - CAN_IT_FMP1, 
    991            *                 - CAN_IT_FF1,
    992            *                 - CAN_IT_FOV1, 
    993            *                 - CAN_IT_EWG, 
    994            *                 - CAN_IT_EPV,
    995            *                 - CAN_IT_LEC, 
    996            *                 - CAN_IT_ERR, 
    997            *                 - CAN_IT_WKU or 
    998            *                 - CAN_IT_SLK.
    999            * @param  NewState: new state of the CAN interrupts.
   1000            *                   This parameter can be: ENABLE or DISABLE.
   1001            * @retval None.
   1002            */

   \                                 In section .text, align 2, keep-with-next
   1003          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1004          {
   1005            /* Check the parameters */
   1006            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1007            assert_param(IS_CAN_IT(CAN_IT));
   1008            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1009          
   1010            if (NewState != DISABLE)
   \                     CAN_ITConfig: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_ITConfig_0
   1011            {
   1012              /* Enable the selected CANx interrupt */
   1013              CANx->IER |= CAN_IT;
   \   00000006   0x6943             LDR      R3,[R0, #+20]
   \   00000008   0x430B             ORRS     R3,R1,R3
   \   0000000A   0x6143             STR      R3,[R0, #+20]
   \   0000000C   0xE002             B.N      ??CAN_ITConfig_1
   1014            }
   1015            else
   1016            {
   1017              /* Disable the selected CANx interrupt */
   1018              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_0: (+1)
   \   0000000E   0x6943             LDR      R3,[R0, #+20]
   \   00000010   0x438B             BICS     R3,R3,R1
   \   00000012   0x6143             STR      R3,[R0, #+20]
   1019            }
   1020          }
   \                     ??CAN_ITConfig_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
   1021          /**
   1022            * @brief  Checks whether the specified CAN flag is set or not.
   1023            * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
   1024            * @param  CAN_FLAG: specifies the flag to check.
   1025            *                   This parameter can be one of the following flags: 
   1026            *                  - CAN_FLAG_EWG
   1027            *                  - CAN_FLAG_EPV 
   1028            *                  - CAN_FLAG_BOF
   1029            *                  - CAN_FLAG_RQCP0
   1030            *                  - CAN_FLAG_RQCP1
   1031            *                  - CAN_FLAG_RQCP2
   1032            *                  - CAN_FLAG_FMP1   
   1033            *                  - CAN_FLAG_FF1       
   1034            *                  - CAN_FLAG_FOV1   
   1035            *                  - CAN_FLAG_FMP0   
   1036            *                  - CAN_FLAG_FF0       
   1037            *                  - CAN_FLAG_FOV0   
   1038            *                  - CAN_FLAG_WKU 
   1039            *                  - CAN_FLAG_SLAK  
   1040            *                  - CAN_FLAG_LEC       
   1041            * @retval The new state of CAN_FLAG (SET or RESET).
   1042            */

   \                                 In section .text, align 2, keep-with-next
   1043          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1044          {
   \                     CAN_GetFlagStatus: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1045            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
   1046            
   1047            /* Check the parameters */
   1048            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1049            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1050            
   1051          
   1052            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   \   00000004   0xF411 0x0F70      TST      R1,#0xF00000
   \   00000008   0xD009             BEQ.N    ??CAN_GetFlagStatus_0
   1053            { 
   1054              /* Check the status of the specified CAN flag */
   1055              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000000A   0x6993             LDR      R3,[R2, #+24]
   \   0000000C   0x400B             ANDS     R3,R1,R3
   \   0000000E   0x031B             LSLS     R3,R3,#+12
   \   00000010   0xD002             BEQ.N    ??CAN_GetFlagStatus_1
   1056              { 
   1057                /* CAN_FLAG is set */
   1058                bitstatus = SET;
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0x0018             MOVS     R0,R3
   \   00000016   0xE02F             B.N      ??CAN_GetFlagStatus_2
   1059              }
   1060              else
   1061              { 
   1062                /* CAN_FLAG is reset */
   1063                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_1: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x0018             MOVS     R0,R3
   \   0000001C   0xE02C             B.N      ??CAN_GetFlagStatus_2
   1064              }
   1065            }
   1066            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_0: (+1)
   \   0000001E   0x01CB             LSLS     R3,R1,#+7
   \   00000020   0xD509             BPL.N    ??CAN_GetFlagStatus_3
   1067            { 
   1068              /* Check the status of the specified CAN flag */
   1069              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   00000022   0x6853             LDR      R3,[R2, #+4]
   \   00000024   0x400B             ANDS     R3,R1,R3
   \   00000026   0x031B             LSLS     R3,R3,#+12
   \   00000028   0xD002             BEQ.N    ??CAN_GetFlagStatus_4
   1070              { 
   1071                /* CAN_FLAG is set */
   1072                bitstatus = SET;
   \   0000002A   0x2301             MOVS     R3,#+1
   \   0000002C   0x0018             MOVS     R0,R3
   \   0000002E   0xE023             B.N      ??CAN_GetFlagStatus_2
   1073              }
   1074              else
   1075              { 
   1076                /* CAN_FLAG is reset */
   1077                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_4: (+1)
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x0018             MOVS     R0,R3
   \   00000034   0xE020             B.N      ??CAN_GetFlagStatus_2
   1078              }
   1079            }
   1080            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_3: (+1)
   \   00000036   0x010B             LSLS     R3,R1,#+4
   \   00000038   0xD509             BPL.N    ??CAN_GetFlagStatus_5
   1081            { 
   1082              /* Check the status of the specified CAN flag */
   1083              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000003A   0x6893             LDR      R3,[R2, #+8]
   \   0000003C   0x400B             ANDS     R3,R1,R3
   \   0000003E   0x031B             LSLS     R3,R3,#+12
   \   00000040   0xD002             BEQ.N    ??CAN_GetFlagStatus_6
   1084              { 
   1085                /* CAN_FLAG is set */
   1086                bitstatus = SET;
   \   00000042   0x2301             MOVS     R3,#+1
   \   00000044   0x0018             MOVS     R0,R3
   \   00000046   0xE017             B.N      ??CAN_GetFlagStatus_2
   1087              }
   1088              else
   1089              { 
   1090                /* CAN_FLAG is reset */
   1091                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_6: (+1)
   \   00000048   0x2300             MOVS     R3,#+0
   \   0000004A   0x0018             MOVS     R0,R3
   \   0000004C   0xE014             B.N      ??CAN_GetFlagStatus_2
   1092              }
   1093            }
   1094            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_5: (+1)
   \   0000004E   0x018B             LSLS     R3,R1,#+6
   \   00000050   0xD509             BPL.N    ??CAN_GetFlagStatus_7
   1095            { 
   1096              /* Check the status of the specified CAN flag */
   1097              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   00000052   0x68D3             LDR      R3,[R2, #+12]
   \   00000054   0x400B             ANDS     R3,R1,R3
   \   00000056   0x031B             LSLS     R3,R3,#+12
   \   00000058   0xD002             BEQ.N    ??CAN_GetFlagStatus_8
   1098              { 
   1099                /* CAN_FLAG is set */
   1100                bitstatus = SET;
   \   0000005A   0x2301             MOVS     R3,#+1
   \   0000005C   0x0018             MOVS     R0,R3
   \   0000005E   0xE00B             B.N      ??CAN_GetFlagStatus_2
   1101              }
   1102              else
   1103              { 
   1104                /* CAN_FLAG is reset */
   1105                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_8: (+1)
   \   00000060   0x2300             MOVS     R3,#+0
   \   00000062   0x0018             MOVS     R0,R3
   \   00000064   0xE008             B.N      ??CAN_GetFlagStatus_2
   1106              }
   1107            }
   1108            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1109            { 
   1110              /* Check the status of the specified CAN flag */
   1111              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_7: (+1)
   \   00000066   0x6913             LDR      R3,[R2, #+16]
   \   00000068   0x400B             ANDS     R3,R1,R3
   \   0000006A   0x031B             LSLS     R3,R3,#+12
   \   0000006C   0xD002             BEQ.N    ??CAN_GetFlagStatus_9
   1112              { 
   1113                /* CAN_FLAG is set */
   1114                bitstatus = SET;
   \   0000006E   0x2301             MOVS     R3,#+1
   \   00000070   0x0018             MOVS     R0,R3
   \   00000072   0xE001             B.N      ??CAN_GetFlagStatus_2
   1115              }
   1116              else
   1117              { 
   1118                /* CAN_FLAG is reset */
   1119                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_9: (+1)
   \   00000074   0x2300             MOVS     R3,#+0
   \   00000076   0x0018             MOVS     R0,R3
   1120              }
   1121            }
   1122            /* Return the CAN_FLAG status */
   1123            return  bitstatus;
   \                     ??CAN_GetFlagStatus_2: (+1)
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x4770             BX       LR               ;; return
   1124          }
   1125          
   1126          /**
   1127            * @brief  Clears the CAN's pending flags.
   1128            * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
   1129            * @param  CAN_FLAG: specifies the flag to clear.
   1130            *                   This parameter can be one of the following flags: 
   1131            *                    - CAN_FLAG_RQCP0
   1132            *                    - CAN_FLAG_RQCP1
   1133            *                    - CAN_FLAG_RQCP2
   1134            *                    - CAN_FLAG_FF1       
   1135            *                    - CAN_FLAG_FOV1   
   1136            *                    - CAN_FLAG_FF0       
   1137            *                    - CAN_FLAG_FOV0   
   1138            *                    - CAN_FLAG_WKU   
   1139            *                    - CAN_FLAG_SLAK    
   1140            *                    - CAN_FLAG_LEC       
   1141            * @retval None.
   1142            */

   \                                 In section .text, align 2, keep-with-next
   1143          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1144          {
   1145            uint32_t flagtmp=0;
   \                     CAN_ClearFlag: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1146            /* Check the parameters */
   1147            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1148            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1149            
   1150            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   \   00000002   0x....             LDR.N    R3,??DataTable6_14  ;; 0x30f00070
   \   00000004   0x4299             CMP      R1,R3
   \   00000006   0xD102             BNE.N    ??CAN_ClearFlag_0
   1151            {
   1152              /* Clear the selected CAN flags */
   1153              CANx->ESR = (uint32_t)RESET;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x6183             STR      R3,[R0, #+24]
   \   0000000C   0xE00F             B.N      ??CAN_ClearFlag_1
   1154            }
   1155            else /* MSR or TSR or RF0R or RF1R */
   1156            {
   1157              flagtmp = CAN_FLAG & 0x000FFFFF;
   \                     ??CAN_ClearFlag_0: (+1)
   \   0000000E   0x030B             LSLS     R3,R1,#+12       ;; ZeroExtS R3,R1,#+12,#+12
   \   00000010   0x0B1B             LSRS     R3,R3,#+12
   \   00000012   0x001A             MOVS     R2,R3
   1158          
   1159              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   \   00000014   0x018B             LSLS     R3,R1,#+6
   \   00000016   0xD501             BPL.N    ??CAN_ClearFlag_2
   1160              {
   1161                /* Receive Flags */
   1162                CANx->RF0R = (uint32_t)(flagtmp);
   \   00000018   0x60C2             STR      R2,[R0, #+12]
   \   0000001A   0xE008             B.N      ??CAN_ClearFlag_1
   1163              }
   1164              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_2: (+1)
   \   0000001C   0x014B             LSLS     R3,R1,#+5
   \   0000001E   0xD501             BPL.N    ??CAN_ClearFlag_3
   1165              {
   1166                /* Receive Flags */
   1167                CANx->RF1R = (uint32_t)(flagtmp);
   \   00000020   0x6102             STR      R2,[R0, #+16]
   \   00000022   0xE004             B.N      ??CAN_ClearFlag_1
   1168              }
   1169              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_3: (+1)
   \   00000024   0x010B             LSLS     R3,R1,#+4
   \   00000026   0xD501             BPL.N    ??CAN_ClearFlag_4
   1170              {
   1171                /* Transmit Flags */
   1172                CANx->TSR = (uint32_t)(flagtmp);
   \   00000028   0x6082             STR      R2,[R0, #+8]
   \   0000002A   0xE000             B.N      ??CAN_ClearFlag_1
   1173              }
   1174              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1175              {
   1176                /* Operating mode Flags */
   1177                CANx->MSR = (uint32_t)(flagtmp);
   \                     ??CAN_ClearFlag_4: (+1)
   \   0000002C   0x6042             STR      R2,[R0, #+4]
   1178              }
   1179            }
   1180          }
   \                     ??CAN_ClearFlag_1: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
   1181          
   1182          /**
   1183            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1184            * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
   1185            * @param  CAN_IT:  specifies the CAN interrupt source to check.
   1186            *                  This parameter can be one of the following flags: 
   1187            *                 -  CAN_IT_TME               
   1188            *                 -  CAN_IT_FMP0              
   1189            *                 -  CAN_IT_FF0               
   1190            *                 -  CAN_IT_FOV0              
   1191            *                 -  CAN_IT_FMP1              
   1192            *                 -  CAN_IT_FF1               
   1193            *                 -  CAN_IT_FOV1              
   1194            *                 -  CAN_IT_WKU  
   1195            *                 -  CAN_IT_SLK  
   1196            *                 -  CAN_IT_EWG    
   1197            *                 -  CAN_IT_EPV    
   1198            *                 -  CAN_IT_BOF    
   1199            *                 -  CAN_IT_LEC    
   1200            *                 -  CAN_IT_ERR 
   1201            * @retval The current state of CAN_IT (SET or RESET).
   1202            */

   \                                 In section .text, align 2, keep-with-next
   1203          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1204          {
   \                     CAN_GetITStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1205            ITStatus itstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1206            /* Check the parameters */
   1207            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1208            assert_param(IS_CAN_IT(CAN_IT));
   1209            
   1210            /* check the enable interrupt bit */
   1211           if((CANx->IER & CAN_IT) != RESET)
   \   00000008   0x6960             LDR      R0,[R4, #+20]
   \   0000000A   0x4228             TST      R0,R5
   \   0000000C   0xD07B             BEQ.N    ??CAN_GetITStatus_0
   1212           {
   1213             /* in case the Interrupt is enabled, .... */
   1214              switch (CAN_IT)
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD021             BEQ.N    ??CAN_GetITStatus_1
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD025             BEQ.N    ??CAN_GetITStatus_2
   \   00000018   0x2804             CMP      R0,#+4
   \   0000001A   0xD029             BEQ.N    ??CAN_GetITStatus_3
   \   0000001C   0x2808             CMP      R0,#+8
   \   0000001E   0xD02D             BEQ.N    ??CAN_GetITStatus_4
   \   00000020   0x2810             CMP      R0,#+16
   \   00000022   0xD031             BEQ.N    ??CAN_GetITStatus_5
   \   00000024   0x2820             CMP      R0,#+32
   \   00000026   0xD035             BEQ.N    ??CAN_GetITStatus_6
   \   00000028   0x2840             CMP      R0,#+64
   \   0000002A   0xD039             BEQ.N    ??CAN_GetITStatus_7
   \   0000002C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000030   0xD048             BEQ.N    ??CAN_GetITStatus_8
   \   00000032   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000036   0xD04B             BEQ.N    ??CAN_GetITStatus_9
   \   00000038   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000003C   0xD04E             BEQ.N    ??CAN_GetITStatus_10
   \   0000003E   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000042   0xD051             BEQ.N    ??CAN_GetITStatus_11
   \   00000044   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000048   0xD054             BEQ.N    ??CAN_GetITStatus_12
   \   0000004A   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000004E   0xD02D             BEQ.N    ??CAN_GetITStatus_13
   \   00000050   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000054   0xD030             BEQ.N    ??CAN_GetITStatus_14
   \   00000056   0xE053             B.N      ??CAN_GetITStatus_15
   1215              {
   1216                case CAN_IT_TME:
   1217                         /* Check CAN_TSR_RQCPx bits */
   1218          	             itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   \                     ??CAN_GetITStatus_1: (+1)
   \   00000058   0x....             LDR.N    R1,??DataTable6_15  ;; 0x10101
   \   0000005A   0x68A0             LDR      R0,[R4, #+8]
   \   0000005C   0x.... 0x....      BL       CheckITStatus
   \   00000060   0x0006             MOVS     R6,R0
   1219          	      break;
   \   00000062   0xE052             B.N      ??CAN_GetITStatus_16
   1220                case CAN_IT_FMP0:
   1221                         /* Check CAN_RF0R_FMP0 bit */
   1222          	             itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   \                     ??CAN_GetITStatus_2: (+1)
   \   00000064   0x2103             MOVS     R1,#+3
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0x.... 0x....      BL       CheckITStatus
   \   0000006C   0x0006             MOVS     R6,R0
   1223          	      break;
   \   0000006E   0xE04C             B.N      ??CAN_GetITStatus_16
   1224                case CAN_IT_FF0:
   1225                         /* Check CAN_RF0R_FULL0 bit */
   1226                         itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   \                     ??CAN_GetITStatus_3: (+1)
   \   00000070   0x2108             MOVS     R1,#+8
   \   00000072   0x68E0             LDR      R0,[R4, #+12]
   \   00000074   0x.... 0x....      BL       CheckITStatus
   \   00000078   0x0006             MOVS     R6,R0
   1227          	      break;
   \   0000007A   0xE046             B.N      ??CAN_GetITStatus_16
   1228                case CAN_IT_FOV0:
   1229                         /* Check CAN_RF0R_FOVR0 bit */
   1230                         itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   \                     ??CAN_GetITStatus_4: (+1)
   \   0000007C   0x2110             MOVS     R1,#+16
   \   0000007E   0x68E0             LDR      R0,[R4, #+12]
   \   00000080   0x.... 0x....      BL       CheckITStatus
   \   00000084   0x0006             MOVS     R6,R0
   1231          	      break;
   \   00000086   0xE040             B.N      ??CAN_GetITStatus_16
   1232                case CAN_IT_FMP1:
   1233                         /* Check CAN_RF1R_FMP1 bit */
   1234                         itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   \                     ??CAN_GetITStatus_5: (+1)
   \   00000088   0x2103             MOVS     R1,#+3
   \   0000008A   0x6920             LDR      R0,[R4, #+16]
   \   0000008C   0x.... 0x....      BL       CheckITStatus
   \   00000090   0x0006             MOVS     R6,R0
   1235          	      break;
   \   00000092   0xE03A             B.N      ??CAN_GetITStatus_16
   1236                case CAN_IT_FF1:
   1237                         /* Check CAN_RF1R_FULL1 bit */
   1238          	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   \                     ??CAN_GetITStatus_6: (+1)
   \   00000094   0x2108             MOVS     R1,#+8
   \   00000096   0x6920             LDR      R0,[R4, #+16]
   \   00000098   0x.... 0x....      BL       CheckITStatus
   \   0000009C   0x0006             MOVS     R6,R0
   1239          	      break;
   \   0000009E   0xE034             B.N      ??CAN_GetITStatus_16
   1240                case CAN_IT_FOV1:
   1241                         /* Check CAN_RF1R_FOVR1 bit */
   1242          	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   \                     ??CAN_GetITStatus_7: (+1)
   \   000000A0   0x2110             MOVS     R1,#+16
   \   000000A2   0x6920             LDR      R0,[R4, #+16]
   \   000000A4   0x.... 0x....      BL       CheckITStatus
   \   000000A8   0x0006             MOVS     R6,R0
   1243          	      break;
   \   000000AA   0xE02E             B.N      ??CAN_GetITStatus_16
   1244                case CAN_IT_WKU:
   1245                         /* Check CAN_MSR_WKUI bit */
   1246                         itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   \                     ??CAN_GetITStatus_13: (+1)
   \   000000AC   0x2108             MOVS     R1,#+8
   \   000000AE   0x6860             LDR      R0,[R4, #+4]
   \   000000B0   0x.... 0x....      BL       CheckITStatus
   \   000000B4   0x0006             MOVS     R6,R0
   1247          	      break;
   \   000000B6   0xE028             B.N      ??CAN_GetITStatus_16
   1248                case CAN_IT_SLK:
   1249                         /* Check CAN_MSR_SLAKI bit */
   1250          	             itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   \                     ??CAN_GetITStatus_14: (+1)
   \   000000B8   0x2110             MOVS     R1,#+16
   \   000000BA   0x6860             LDR      R0,[R4, #+4]
   \   000000BC   0x.... 0x....      BL       CheckITStatus
   \   000000C0   0x0006             MOVS     R6,R0
   1251          	      break;
   \   000000C2   0xE022             B.N      ??CAN_GetITStatus_16
   1252                case CAN_IT_EWG:
   1253                         /* Check CAN_ESR_EWGF bit */
   1254          	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   \                     ??CAN_GetITStatus_8: (+1)
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x69A0             LDR      R0,[R4, #+24]
   \   000000C8   0x.... 0x....      BL       CheckITStatus
   \   000000CC   0x0006             MOVS     R6,R0
   1255          	      break;
   \   000000CE   0xE01C             B.N      ??CAN_GetITStatus_16
   1256                case CAN_IT_EPV:
   1257                         /* Check CAN_ESR_EPVF bit */
   1258          	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   \                     ??CAN_GetITStatus_9: (+1)
   \   000000D0   0x2102             MOVS     R1,#+2
   \   000000D2   0x69A0             LDR      R0,[R4, #+24]
   \   000000D4   0x.... 0x....      BL       CheckITStatus
   \   000000D8   0x0006             MOVS     R6,R0
   1259          	      break;
   \   000000DA   0xE016             B.N      ??CAN_GetITStatus_16
   1260                case CAN_IT_BOF:
   1261                         /* Check CAN_ESR_BOFF bit */
   1262          	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   \                     ??CAN_GetITStatus_10: (+1)
   \   000000DC   0x2104             MOVS     R1,#+4
   \   000000DE   0x69A0             LDR      R0,[R4, #+24]
   \   000000E0   0x.... 0x....      BL       CheckITStatus
   \   000000E4   0x0006             MOVS     R6,R0
   1263          	      break;
   \   000000E6   0xE010             B.N      ??CAN_GetITStatus_16
   1264                case CAN_IT_LEC:
   1265                         /* Check CAN_ESR_LEC bit */
   1266          	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   \                     ??CAN_GetITStatus_11: (+1)
   \   000000E8   0x2170             MOVS     R1,#+112
   \   000000EA   0x69A0             LDR      R0,[R4, #+24]
   \   000000EC   0x.... 0x....      BL       CheckITStatus
   \   000000F0   0x0006             MOVS     R6,R0
   1267          	      break;
   \   000000F2   0xE00A             B.N      ??CAN_GetITStatus_16
   1268                case CAN_IT_ERR:
   1269                         /* Check CAN_MSR_ERRI bit */ 
   1270                         itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   \                     ??CAN_GetITStatus_12: (+1)
   \   000000F4   0x2104             MOVS     R1,#+4
   \   000000F6   0x6860             LDR      R0,[R4, #+4]
   \   000000F8   0x.... 0x....      BL       CheckITStatus
   \   000000FC   0x0006             MOVS     R6,R0
   1271          	      break;
   \   000000FE   0xE004             B.N      ??CAN_GetITStatus_16
   1272                default :
   1273                         /* in case of error, return RESET */
   1274                        itstatus = RESET;
   \                     ??CAN_GetITStatus_15: (+1)
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x0006             MOVS     R6,R0
   1275                        break;
   \   00000104   0xE001             B.N      ??CAN_GetITStatus_16
   1276              }
   1277            }
   1278            else
   1279            {
   1280             /* in case the Interrupt is not enabled, return RESET */
   1281              itstatus  = RESET;
   \                     ??CAN_GetITStatus_0: (+1)
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x0006             MOVS     R6,R0
   1282            }
   1283            
   1284            /* Return the CAN_IT status */
   1285            return  itstatus;
   \                     ??CAN_GetITStatus_16: (+1)
   \   0000010A   0x0030             MOVS     R0,R6
   \   0000010C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010E   0xBD70             POP      {R4-R6,PC}       ;; return
   1286          }
   1287          
   1288          /**
   1289            * @brief  Clears the CANx's interrupt pending bits.
   1290            * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
   1291            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1292            *                  -  CAN_IT_TME                     
   1293            *                  -  CAN_IT_FF0               
   1294            *                  -  CAN_IT_FOV0                     
   1295            *                  -  CAN_IT_FF1               
   1296            *                  -  CAN_IT_FOV1              
   1297            *                  -  CAN_IT_WKU  
   1298            *                  -  CAN_IT_SLK  
   1299            *                  -  CAN_IT_EWG    
   1300            *                  -  CAN_IT_EPV    
   1301            *                  -  CAN_IT_BOF    
   1302            *                  -  CAN_IT_LEC    
   1303            *                  -  CAN_IT_ERR 
   1304            * @retval None.
   1305            */

   \                                 In section .text, align 2, keep-with-next
   1306          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1307          {
   1308            /* Check the parameters */
   1309            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1310            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1311          
   1312            switch (CAN_IT)
   \                     CAN_ClearITPendingBit: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xD01D             BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000006   0x2A04             CMP      R2,#+4
   \   00000008   0xD01E             BEQ.N    ??CAN_ClearITPendingBit_1
   \   0000000A   0x2A08             CMP      R2,#+8
   \   0000000C   0xD01F             BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000000E   0x2A20             CMP      R2,#+32
   \   00000010   0xD020             BEQ.N    ??CAN_ClearITPendingBit_3
   \   00000012   0x2A40             CMP      R2,#+64
   \   00000014   0xD021             BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000016   0xF5B2 0x7F80      CMP      R2,#+256
   \   0000001A   0xD027             BEQ.N    ??CAN_ClearITPendingBit_5
   \   0000001C   0xF5B2 0x7F00      CMP      R2,#+512
   \   00000020   0xD027             BEQ.N    ??CAN_ClearITPendingBit_6
   \   00000022   0xF5B2 0x6F80      CMP      R2,#+1024
   \   00000026   0xD027             BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000028   0xF5B2 0x6F00      CMP      R2,#+2048
   \   0000002C   0xD027             BEQ.N    ??CAN_ClearITPendingBit_8
   \   0000002E   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000032   0xD029             BEQ.N    ??CAN_ClearITPendingBit_9
   \   00000034   0xF5B2 0x3F80      CMP      R2,#+65536
   \   00000038   0xD012             BEQ.N    ??CAN_ClearITPendingBit_10
   \   0000003A   0xF5B2 0x3F00      CMP      R2,#+131072
   \   0000003E   0xD012             BEQ.N    ??CAN_ClearITPendingBit_11
   \   00000040   0xE027             B.N      ??CAN_ClearITPendingBit_12
   1313            {
   1314                case CAN_IT_TME:
   1315                        /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1316          	      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   \                     ??CAN_ClearITPendingBit_0: (+1)
   \   00000042   0x....             LDR.N    R2,??DataTable6_15  ;; 0x10101
   \   00000044   0x6082             STR      R2,[R0, #+8]
   1317          	      break;
   \   00000046   0xE024             B.N      ??CAN_ClearITPendingBit_13
   1318                case CAN_IT_FF0:
   1319                        /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1320          	      CANx->RF0R = CAN_RF0R_FULL0; 
   \                     ??CAN_ClearITPendingBit_1: (+1)
   \   00000048   0x2208             MOVS     R2,#+8
   \   0000004A   0x60C2             STR      R2,[R0, #+12]
   1321          	      break;
   \   0000004C   0xE021             B.N      ??CAN_ClearITPendingBit_13
   1322                case CAN_IT_FOV0:
   1323                        /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1324          	      CANx->RF0R = CAN_RF0R_FOVR0; 
   \                     ??CAN_ClearITPendingBit_2: (+1)
   \   0000004E   0x2210             MOVS     R2,#+16
   \   00000050   0x60C2             STR      R2,[R0, #+12]
   1325          	      break;
   \   00000052   0xE01E             B.N      ??CAN_ClearITPendingBit_13
   1326                case CAN_IT_FF1:
   1327                        /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1328          	      CANx->RF1R = CAN_RF1R_FULL1;  
   \                     ??CAN_ClearITPendingBit_3: (+1)
   \   00000054   0x2208             MOVS     R2,#+8
   \   00000056   0x6102             STR      R2,[R0, #+16]
   1329          	      break;
   \   00000058   0xE01B             B.N      ??CAN_ClearITPendingBit_13
   1330                case CAN_IT_FOV1:
   1331                        /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1332          	      CANx->RF1R = CAN_RF1R_FOVR1; 
   \                     ??CAN_ClearITPendingBit_4: (+1)
   \   0000005A   0x2210             MOVS     R2,#+16
   \   0000005C   0x6102             STR      R2,[R0, #+16]
   1333          	      break;
   \   0000005E   0xE018             B.N      ??CAN_ClearITPendingBit_13
   1334                case CAN_IT_WKU:
   1335                        /* Clear CAN_MSR_WKUI (rc_w1)*/
   1336          	      CANx->MSR = CAN_MSR_WKUI;  
   \                     ??CAN_ClearITPendingBit_10: (+1)
   \   00000060   0x2208             MOVS     R2,#+8
   \   00000062   0x6042             STR      R2,[R0, #+4]
   1337          	      break;
   \   00000064   0xE015             B.N      ??CAN_ClearITPendingBit_13
   1338                case CAN_IT_SLK:
   1339                        /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1340          	      CANx->MSR = CAN_MSR_SLAKI;   
   \                     ??CAN_ClearITPendingBit_11: (+1)
   \   00000066   0x2210             MOVS     R2,#+16
   \   00000068   0x6042             STR      R2,[R0, #+4]
   1341          	      break;
   \   0000006A   0xE012             B.N      ??CAN_ClearITPendingBit_13
   1342                case CAN_IT_EWG:
   1343                        /* Clear CAN_MSR_ERRI (rc_w1) */
   1344          	      CANx->MSR = CAN_MSR_ERRI;
   \                     ??CAN_ClearITPendingBit_5: (+1)
   \   0000006C   0x2204             MOVS     R2,#+4
   \   0000006E   0x6042             STR      R2,[R0, #+4]
   1345                        /* Note : the corresponding Flag is cleared by hardware depending 
   1346                                  of the CAN Bus status*/ 
   1347          	      break;
   \   00000070   0xE00F             B.N      ??CAN_ClearITPendingBit_13
   1348                case CAN_IT_EPV:
   1349                        /* Clear CAN_MSR_ERRI (rc_w1) */
   1350          	      CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_6: (+1)
   \   00000072   0x2204             MOVS     R2,#+4
   \   00000074   0x6042             STR      R2,[R0, #+4]
   1351                        /* Note : the corresponding Flag is cleared by hardware depending 
   1352                                  of the CAN Bus status*/
   1353          	      break;
   \   00000076   0xE00C             B.N      ??CAN_ClearITPendingBit_13
   1354                case CAN_IT_BOF:
   1355                        /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1356          	      CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_7: (+1)
   \   00000078   0x2204             MOVS     R2,#+4
   \   0000007A   0x6042             STR      R2,[R0, #+4]
   1357                        /* Note : the corresponding Flag is cleared by hardware depending 
   1358                                  of the CAN Bus status*/
   1359          	      break;
   \   0000007C   0xE009             B.N      ??CAN_ClearITPendingBit_13
   1360                case CAN_IT_LEC:
   1361                        /*  Clear LEC bits */
   1362          	      CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_8: (+1)
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0x6182             STR      R2,[R0, #+24]
   1363                        /* Clear CAN_MSR_ERRI (rc_w1) */
   1364          	      CANx->MSR = CAN_MSR_ERRI; 
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0x6042             STR      R2,[R0, #+4]
   1365          	      break;
   \   00000086   0xE004             B.N      ??CAN_ClearITPendingBit_13
   1366                case CAN_IT_ERR:
   1367                        /*Clear LEC bits */
   1368          	      CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_9: (+1)
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x6182             STR      R2,[R0, #+24]
   1369                        /* Clear CAN_MSR_ERRI (rc_w1) */
   1370          	      CANx->MSR = CAN_MSR_ERRI; 
   \   0000008C   0x2204             MOVS     R2,#+4
   \   0000008E   0x6042             STR      R2,[R0, #+4]
   1371          	      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending 
   1372                            of the CAN Bus status*/
   1373          	      break;
   \   00000090   0xE7FF             B.N      ??CAN_ClearITPendingBit_13
   1374                default :
   1375          	      break;
   1376             }
   1377          }
   \                     ??CAN_ClearITPendingBit_12: (+1)
   \                     ??CAN_ClearITPendingBit_13: (+1)
   \   00000092   0x4770             BX       LR               ;; return
   1378          
   1379          /**
   1380            * @brief  Checks whether the CAN interrupt has occurred or not.
   1381            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1382            * @param  It_Bit:  specifies the interrupt source bit to check.
   1383            * @retval The new state of the CAN Interrupt (SET or RESET).
   1384            */

   \                                 In section .text, align 2, keep-with-next
   1385          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1386          {
   \                     CheckITStatus: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1387            ITStatus pendingbitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
   1388            
   1389            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   \   00000004   0x420A             TST      R2,R1
   \   00000006   0xD002             BEQ.N    ??CheckITStatus_0
   1390            {
   1391              /* CAN_IT is set */
   1392              pendingbitstatus = SET;
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x0018             MOVS     R0,R3
   \   0000000C   0xE001             B.N      ??CheckITStatus_1
   1393            }
   1394            else
   1395            {
   1396              /* CAN_IT is reset */
   1397              pendingbitstatus = RESET;
   \                     ??CheckITStatus_0: (+1)
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x0018             MOVS     R0,R3
   1398            }
   1399            return pendingbitstatus;
   \                     ??CheckITStatus_1: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1400          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40006600         DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x4000661C         DC32     0x4000661c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x4000660C         DC32     0x4000660c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x40006640         DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40006604         DC32     0x40006604

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40006614         DC32     0x40006614

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0xFFFFC0F1         DC32     0xffffc0f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x04000003         DC32     0x4000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x08000300         DC32     0x8000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x10030000         DC32     0x10030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x04000001         DC32     0x4000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x040000FD         DC32     0x40000fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x0800FD00         DC32     0x800fd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x30F00070         DC32     0x30f00070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x00010101         DC32     0x10101
   1401          
   1402          
   1403          /**
   1404            * @}
   1405            */
   1406          
   1407          /**
   1408            * @}
   1409            */
   1410          
   1411          /**
   1412            * @}
   1413            */
   1414          
   1415          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
       4   CAN_FilterInit
       0   CAN_GetFlagStatus
      16   CAN_GetITStatus
        16   -> CheckITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       0   CAN_ITConfig
       8   CAN_Init
       0   CAN_MessagePending
       4   CAN_OperatingModeRequest
       0   CAN_Receive
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       0   CAN_TTComModeCmd
       8   CAN_Transmit
       4   CAN_TransmitStatus
       0   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      46  CAN_CancelTransmit
      48  CAN_ClearFlag
     148  CAN_ClearITPendingBit
      26  CAN_DBGFreeze
      56  CAN_DeInit
      26  CAN_FIFORelease
     274  CAN_FilterInit
     124  CAN_GetFlagStatus
     272  CAN_GetITStatus
      14  CAN_GetLSBTransmitErrorCounter
      16  CAN_GetLastErrorCode
      14  CAN_GetReceiveErrorCounter
      22  CAN_ITConfig
     280  CAN_Init
      44  CAN_MessagePending
     186  CAN_OperatingModeRequest
     232  CAN_Receive
      70  CAN_SlaveStartBank
      34  CAN_Sleep
      46  CAN_StructInit
      98  CAN_TTComModeCmd
     294  CAN_Transmit
     164  CAN_TransmitStatus
      44  CAN_WakeUp
      22  CheckITStatus

 
 2 664 bytes in section .text
 
 2 664 bytes of CODE memory

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       12/Sep/2016  16:26:12
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\ilya\vendicont\arm-periphery\Application\lcd_2x16.c
#    Command line =  
#        C:\ilya\vendicont\arm-periphery\Application\lcd_2x16.c -D STM32F10X_HD
#        -D USE_STDPERIPH_DRIVER -D NDEBUG -D _FLASH_PROG -lCN
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Release\List
#        --remarks -o
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Release\Obj
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\ -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\library\CMSIS\Include\
#        -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\library\STM32F10x_StdPeriph_Driver\inc\
#        -I C:\ilya\vendicont\arm-periphery\build\iar\..\..\rtos\embos\iar\inc\
#        -I C:\ilya\vendicont\arm-periphery\build\iar\..\..\Inc\ -I
#        C:\ilya\vendicont\arm-periphery\build\iar\..\..\Application\p-types\
#        -Ohs --use_c++_inline --require_prototypes
#    List file    =  
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Release\List\lcd_2x16.lst
#    Object file  =  
#        C:\ilya\vendicont\arm-periphery\build\iar\Output\Release\Obj\lcd_2x16.o
#
###############################################################################

C:\ilya\vendicont\arm-periphery\Application\lcd_2x16.c
      1          #include "stm32f10x.h"
      2          #include "RTOS.h"
      3          #include "BSP.h"
      4          #include "lcd_2x16.h"
      5          #include "stm32f10x_gpio.h"
      6          #include "stm32f10x_rcc.h"
      7          

   \                                 In section .bss, align 4
      8          OS_RSEMA SemaLCD;
   \                     SemaLCD:
   \   00000000                      DS8 16
      9          
     10          extern GPIO_InitTypeDef GPIO_InitStructure;

   \                                 In section .bss, align 4
     11          static vu32 TimingDelay;
   \                     TimingDelay:
   \   00000000                      DS8 4
     12          
     13          
     14          //unsigned char lcd_buf[ 32 ];
     15          
     16          /****************************/
     17          /* Strobe 4-Bit Data to LCD */
     18          /****************************/

   \                                 In section .text, align 2, keep-with-next
     19          void lcd_out_data4(unsigned char val)
     20          {
   \                     lcd_out_data4: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
     21            if((val&0x01)==0x01)	// Bit[0]
   \   00000006   0x07E0             LSLS     R0,R4,#+31
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable10  ;; 0x40011000
   \   0000000C   0xBF4C             ITE      MI 
   \   0000000E   0x2201             MOVMI    R2,#+1
   \   00000010   0x2200             MOVPL    R2,#+0
     22            {
     23              LCD_D4_HI();
     24            }
     25            else
     26            {
     27              LCD_D4_LO();
   \   00000012   0x2108             MOVS     R1,#+8
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       GPIO_WriteBit
     28            }
     29          
     30            if((val&0x02)==0x02)  // Bit[1]
   \   0000001A   0x07A0             LSLS     R0,R4,#+30
   \   0000001C   0xBF4C             ITE      MI 
   \   0000001E   0x2201             MOVMI    R2,#+1
   \   00000020   0x2200             MOVPL    R2,#+0
     31            {
     32              LCD_D5_HI();
     33            }
     34            else
     35            {
     36              LCD_D5_LO();
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       GPIO_WriteBit
     37            }
     38          
     39            if((val&0x04)==0x04)  // Bit[2]
   \   0000002A   0x0760             LSLS     R0,R4,#+29
   \   0000002C   0xBF4C             ITE      MI 
   \   0000002E   0x2201             MOVMI    R2,#+1
   \   00000030   0x2200             MOVPL    R2,#+0
     40            {
     41              LCD_D6_HI();
     42            }
     43            else
     44            {
     45              LCD_D6_LO();
   \   00000032   0x2102             MOVS     R1,#+2
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       GPIO_WriteBit
     46            }
     47          
     48            if((val&0x08)==0x08)  // Bit[3]
   \   0000003A   0x0720             LSLS     R0,R4,#+28
   \   0000003C   0xBF47             ITTEE    MI 
   \   0000003E   0x2201             MOVMI    R2,#+1
   \   00000040   0x2101             MOVMI    R1,#+1
   \   00000042   0x2200             MOVPL    R2,#+0
   \   00000044   0x2101             MOVPL    R1,#+1
     49            {
     50              LCD_D7_HI();
     51            }
     52            else
     53            {
     54              LCD_D7_LO();
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000004E   0x.... 0x....      B.W      GPIO_WriteBit
     55            }
     56          
     57          }
     58          
     59          /****************************/
     60          /* Write Data 1 Byte to LCD */
     61          /****************************/

   \                                 In section .text, align 2, keep-with-next
     62          void lcd_write_byte(unsigned char val)
     63          {
   \                     lcd_write_byte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
     64            lcd_out_data4((val>>4)&0x0F);							// Strobe 4-Bit High-Nibble to LCD
   \   00000006   0x0900             LSRS     R0,R0,#+4
   \   00000008   0x.... 0x....      BL       lcd_out_data4
     65            enable_lcd();											// Enable Pulse
   \   0000000C   0x.... 0x....      BL       enable_lcd
     66          
     67            lcd_out_data4(val&0x0F);				  				// Strobe 4-Bit Low-Nibble to LCD
   \   00000010   0xF004 0x000F      AND      R0,R4,#0xF
   \   00000014   0x.... 0x....      BL       lcd_out_data4
     68            enable_lcd();											// Enable Pulse
   \   00000018   0x.... 0x....      BL       enable_lcd
     69          
     70            while(busy_lcd());      								// Wait LCD Execute Complete
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xB118             CBZ.N    R0,??lcd_write_byte_0
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       OS_Delay
   \   0000002A   0xE006             B.N      ??lcd_write_byte_1
   \                     ??lcd_write_byte_0: (+1)
   \   0000002C   0x2064             MOVS     R0,#+100
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \                     ??lcd_write_byte_2: (+1)
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0x1E41             SUBS     R1,R0,#+1
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0x9100             STR      R1,[SP, #+0]
   \   00000038   0xD1FA             BNE.N    ??lcd_write_byte_2
   \                     ??lcd_write_byte_1: (+1)
   \   0000003A   0xB002             ADD      SP,SP,#+8
   \   0000003C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000040   0x.... 0x....      B.W      IWDG_ReloadCounter
     71          }
     72          
     73          /****************************/
     74          /* Write Instruction to LCD */
     75          /****************************/

   \                                 In section .text, align 2, keep-with-next
     76          void lcd_write_control(unsigned char val)
     77          {
   \                     lcd_write_control: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     78            LCD_RS_LO();											// RS = 0 = Instruction Select
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF44F 0x5180      MOV      R1,#+4096
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011000
   \   0000000E   0x.... 0x....      BL       GPIO_WriteBit
     79            lcd_write_byte(val);									// Strobe Command Byte
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x....             B.N      lcd_write_byte
     80          }
     81          
     82          /****************************/
     83          /* Write Data(ASCII) to LCD */
     84          /****************************/

   \                                 In section .text, align 2, keep-with-next
     85          void lcd_write_ascii(unsigned char c)
     86          {
   \                     lcd_write_ascii: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     87            LCD_RS_HI();											// RS = 1 = Data Select
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF44F 0x5180      MOV      R1,#+4096
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011000
   \   0000000E   0x.... 0x....      BL       GPIO_WriteBit
     88            lcd_write_byte(c);		   							// Strobe 1 Byte to LCD
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x....             B.N      lcd_write_byte
     89          }
     90          
     91          /*******************************/
     92          /* Initial 4-Bit LCD Interface */
     93          /*******************************/

   \                                 In section .text, align 2, keep-with-next
     94          void lcd_init(void)
     95          {
   \                     lcd_init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     96            /* Configure IO connected to LCD16X2 */
     97            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_RW, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2010             MOVS     R0,#+16
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     98            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable10_2
     99            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    100            GPIO_InitStructure.GPIO_Pin = LCD_EN_PIN;
    101            GPIO_Init((GPIO_TypeDef*)GPIOC_BASE, &GPIO_InitStructure);
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable10  ;; 0x40011000
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x70A8             STRB     R0,[R5, #+2]
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x2010             MOVS     R0,#+16
   \   0000001C   0x70E8             STRB     R0,[R5, #+3]
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000022   0x8028             STRH     R0,[R5, #+0]
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       GPIO_Init
    102          
    103          //  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_RW, ENABLE);
    104            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x70A8             STRB     R0,[R5, #+2]
    105            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    106            GPIO_InitStructure.GPIO_Pin = LCD_RW_PIN;
    107            GPIO_Init((GPIO_TypeDef*)GPIOC_BASE, &GPIO_InitStructure);
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x2010             MOVS     R0,#+16
   \   00000032   0x70E8             STRB     R0,[R5, #+3]
   \   00000034   0xF44F 0x6000      MOV      R0,#+2048
   \   00000038   0x8028             STRH     R0,[R5, #+0]
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       GPIO_Init
    108          
    109          //  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_RS, ENABLE);
    110            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x70A8             STRB     R0,[R5, #+2]
    111            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    112            GPIO_InitStructure.GPIO_Pin = LCD_RS_PIN;
    113            GPIO_Init((GPIO_TypeDef*)GPIOC_BASE, &GPIO_InitStructure);
   \   00000044   0x4629             MOV      R1,R5
   \   00000046   0x2010             MOVS     R0,#+16
   \   00000048   0x70E8             STRB     R0,[R5, #+3]
   \   0000004A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000004E   0x8028             STRH     R0,[R5, #+0]
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       GPIO_Init
    114          
    115          //  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DATA, ENABLE);
    116            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0x70A8             STRB     R0,[R5, #+2]
    117            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    118            GPIO_InitStructure.GPIO_Pin = LCD_D4_PIN |
    119                                          LCD_D5_PIN |
    120          				LCD_D6_PIN |
    121                                          LCD_D7_PIN;
    122            GPIO_Init((GPIO_TypeDef*)GPIOC_BASE, &GPIO_InitStructure);
   \   0000005A   0x4629             MOV      R1,R5
   \   0000005C   0x2010             MOVS     R0,#+16
   \   0000005E   0x70E8             STRB     R0,[R5, #+3]
   \   00000060   0x200F             MOVS     R0,#+15
   \   00000062   0x8028             STRH     R0,[R5, #+0]
   \   00000064   0xF643 0x2598      MOVW     R5,#+15000
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       GPIO_Init
    123          
    124            LCD_D4_HI();
   \   0000006E   0x2201             MOVS     R2,#+1
   \   00000070   0x2108             MOVS     R1,#+8
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       GPIO_WriteBit
    125            LCD_D5_HI();
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0x2104             MOVS     R1,#+4
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       GPIO_WriteBit
    126            LCD_D6_LO();
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x2102             MOVS     R1,#+2
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       GPIO_WriteBit
    127            LCD_D7_LO();
   \   0000008C   0x2200             MOVS     R2,#+0
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       GPIO_WriteBit
    128            DelayuS(15000);										// Power-On Delay (15 mS)
   \   00000096   0x9500             STR      R5,[SP, #+0]
   \                     ??lcd_init_0: (+1)
   \   00000098   0x9800             LDR      R0,[SP, #+0]
   \   0000009A   0x1E41             SUBS     R1,R0,#+1
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0x9100             STR      R1,[SP, #+0]
   \   000000A0   0xD1FA             BNE.N    ??lcd_init_0
    129          
    130            LCD_D4_HI();
   \   000000A2   0x2201             MOVS     R2,#+1
   \   000000A4   0x2108             MOVS     R1,#+8
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       GPIO_WriteBit
    131            LCD_D5_HI();
   \   000000AC   0x2201             MOVS     R2,#+1
   \   000000AE   0x2104             MOVS     R1,#+4
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       GPIO_WriteBit
    132            LCD_D6_LO();
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0x2102             MOVS     R1,#+2
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       GPIO_WriteBit
    133            LCD_D7_LO();
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x2101             MOVS     R1,#+1
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0x.... 0x....      BL       GPIO_WriteBit
    134            enable_lcd();											// Enable Pulse
   \   000000CA   0x.... 0x....      BL       enable_lcd
    135            DelayuS(4100);										// Delay 4.1mS
   \   000000CE   0xF241 0x0004      MOVW     R0,#+4100
   \   000000D2   0x9000             STR      R0,[SP, #+0]
   \                     ??lcd_init_1: (+1)
   \   000000D4   0x9800             LDR      R0,[SP, #+0]
   \   000000D6   0x1E41             SUBS     R1,R0,#+1
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0x9100             STR      R1,[SP, #+0]
   \   000000DC   0xD1FA             BNE.N    ??lcd_init_1
    136          
    137            LCD_D4_HI();
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x2108             MOVS     R1,#+8
   \   000000E2   0x4620             MOV      R0,R4
   \   000000E4   0x.... 0x....      BL       GPIO_WriteBit
    138            LCD_D5_HI();
   \   000000E8   0x2201             MOVS     R2,#+1
   \   000000EA   0x2104             MOVS     R1,#+4
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x.... 0x....      BL       GPIO_WriteBit
    139            LCD_D6_LO();
   \   000000F2   0x2200             MOVS     R2,#+0
   \   000000F4   0x2102             MOVS     R1,#+2
   \   000000F6   0x4620             MOV      R0,R4
   \   000000F8   0x.... 0x....      BL       GPIO_WriteBit
    140            LCD_D7_LO();
   \   000000FC   0x2200             MOVS     R2,#+0
   \   000000FE   0x2101             MOVS     R1,#+1
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0x.... 0x....      BL       GPIO_WriteBit
    141            enable_lcd();											// Enable Pulse
   \   00000106   0x.... 0x....      BL       enable_lcd
    142            DelayuS(100);											// delay 100uS
   \   0000010A   0x2064             MOVS     R0,#+100
   \   0000010C   0x9000             STR      R0,[SP, #+0]
   \                     ??lcd_init_2: (+1)
   \   0000010E   0x9800             LDR      R0,[SP, #+0]
   \   00000110   0x1E41             SUBS     R1,R0,#+1
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0x9100             STR      R1,[SP, #+0]
   \   00000116   0xD1FA             BNE.N    ??lcd_init_2
    143          
    144            LCD_D4_HI();
   \   00000118   0x2201             MOVS     R2,#+1
   \   0000011A   0x2108             MOVS     R1,#+8
   \   0000011C   0x4620             MOV      R0,R4
   \   0000011E   0x.... 0x....      BL       GPIO_WriteBit
    145            LCD_D5_HI();
   \   00000122   0x2201             MOVS     R2,#+1
   \   00000124   0x2104             MOVS     R1,#+4
   \   00000126   0x4620             MOV      R0,R4
   \   00000128   0x.... 0x....      BL       GPIO_WriteBit
    146            LCD_D6_LO();
   \   0000012C   0x2200             MOVS     R2,#+0
   \   0000012E   0x2102             MOVS     R1,#+2
   \   00000130   0x4620             MOV      R0,R4
   \   00000132   0x.... 0x....      BL       GPIO_WriteBit
    147            LCD_D7_LO();
   \   00000136   0x2200             MOVS     R2,#+0
   \   00000138   0x2101             MOVS     R1,#+1
   \   0000013A   0x4620             MOV      R0,R4
   \   0000013C   0x.... 0x....      BL       GPIO_WriteBit
    148            enable_lcd();											// Enable Pulse
   \   00000140   0x.... 0x....      BL       enable_lcd
    149            //while(busy_lcd());      								// Wait LCD Execute Complete
    150             DelayuS(1000);
   \   00000144   0xF44F 0x767A      MOV      R6,#+1000
   \   00000148   0x9600             STR      R6,[SP, #+0]
   \                     ??lcd_init_3: (+1)
   \   0000014A   0x9800             LDR      R0,[SP, #+0]
   \   0000014C   0x1E41             SUBS     R1,R0,#+1
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0x9100             STR      R1,[SP, #+0]
   \   00000152   0xD1FA             BNE.N    ??lcd_init_3
    151          
    152            LCD_D4_LO();
   \   00000154   0x2200             MOVS     R2,#+0
   \   00000156   0x2108             MOVS     R1,#+8
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0x.... 0x....      BL       GPIO_WriteBit
    153            LCD_D5_HI();
   \   0000015E   0x2201             MOVS     R2,#+1
   \   00000160   0x2104             MOVS     R1,#+4
   \   00000162   0x4620             MOV      R0,R4
   \   00000164   0x.... 0x....      BL       GPIO_WriteBit
    154            LCD_D6_LO();
   \   00000168   0x2200             MOVS     R2,#+0
   \   0000016A   0x2102             MOVS     R1,#+2
   \   0000016C   0x4620             MOV      R0,R4
   \   0000016E   0x.... 0x....      BL       GPIO_WriteBit
    155            LCD_D7_LO();
   \   00000172   0x2200             MOVS     R2,#+0
   \   00000174   0x2101             MOVS     R1,#+1
   \   00000176   0x4620             MOV      R0,R4
   \   00000178   0x.... 0x....      BL       GPIO_WriteBit
    156            enable_lcd();											// Enable Pulse
   \   0000017C   0x2201             MOVS     R2,#+1
   \   0000017E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000182   0x4620             MOV      R0,R4
   \   00000184   0x.... 0x....      BL       GPIO_WriteBit
   \   00000188   0x2032             MOVS     R0,#+50
   \   0000018A   0x9000             STR      R0,[SP, #+0]
   \                     ??lcd_init_4: (+1)
   \   0000018C   0x9800             LDR      R0,[SP, #+0]
   \   0000018E   0x1E41             SUBS     R1,R0,#+1
   \   00000190   0x2800             CMP      R0,#+0
   \   00000192   0x9100             STR      R1,[SP, #+0]
   \   00000194   0xD1FA             BNE.N    ??lcd_init_4
   \   00000196   0x2200             MOVS     R2,#+0
   \   00000198   0xF44F 0x6180      MOV      R1,#+1024
   \   0000019C   0x4620             MOV      R0,R4
   \   0000019E   0x.... 0x....      BL       GPIO_WriteBit
    157            //while(busy_lcd());      								// Wait LCD Execute Complete
    158             DelayuS(1000);
   \   000001A2   0x9600             STR      R6,[SP, #+0]
   \                     ??lcd_init_5: (+1)
   \   000001A4   0x9800             LDR      R0,[SP, #+0]
   \   000001A6   0x1E41             SUBS     R1,R0,#+1
   \   000001A8   0x2800             CMP      R0,#+0
   \   000001AA   0x9100             STR      R1,[SP, #+0]
   \   000001AC   0xD1FA             BNE.N    ??lcd_init_5
    159          
    160            lcd_write_control(0x28);  							// Function Set (DL=0 4-Bit,N=1 2 Line,F=0 5X7)
   \   000001AE   0x2200             MOVS     R2,#+0
   \   000001B0   0xF44F 0x5180      MOV      R1,#+4096
   \   000001B4   0x4620             MOV      R0,R4
   \   000001B6   0x.... 0x....      BL       GPIO_WriteBit
   \   000001BA   0x2028             MOVS     R0,#+40
   \   000001BC   0x.... 0x....      BL       lcd_write_byte
    161            lcd_write_control(0x0C);  							// Display on/off Control (Entry Display,Cursor off,Cursor not Blink)
   \   000001C0   0x2200             MOVS     R2,#+0
   \   000001C2   0xF44F 0x5180      MOV      R1,#+4096
   \   000001C6   0x4620             MOV      R0,R4
   \   000001C8   0x.... 0x....      BL       GPIO_WriteBit
   \   000001CC   0x200C             MOVS     R0,#+12
   \   000001CE   0x.... 0x....      BL       lcd_write_byte
    162            lcd_write_control(0x06);  							// Entry Mode Set (I/D=1 Increment,S=0 Cursor Shift)
   \   000001D2   0x2200             MOVS     R2,#+0
   \   000001D4   0xF44F 0x5180      MOV      R1,#+4096
   \   000001D8   0x4620             MOV      R0,R4
   \   000001DA   0x.... 0x....      BL       GPIO_WriteBit
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0x.... 0x....      BL       lcd_out_data4
   \   000001E4   0x.... 0x....      BL       enable_lcd
   \   000001E8   0x2006             MOVS     R0,#+6
   \   000001EA   0x.... 0x....      BL       lcd_out_data4
   \   000001EE   0x.... 0x....      BL       enable_lcd
   \   000001F2   0x....             LDR.N    R6,??DataTable10_1
   \   000001F4   0x7830             LDRB     R0,[R6, #+0]
   \   000001F6   0xB118             CBZ.N    R0,??lcd_init_6
   \   000001F8   0x2001             MOVS     R0,#+1
   \   000001FA   0x.... 0x....      BL       OS_Delay
   \   000001FE   0xE006             B.N      ??lcd_init_7
   \                     ??lcd_init_6: (+1)
   \   00000200   0x2064             MOVS     R0,#+100
   \   00000202   0x9000             STR      R0,[SP, #+0]
   \                     ??lcd_init_8: (+1)
   \   00000204   0x9800             LDR      R0,[SP, #+0]
   \   00000206   0x1E41             SUBS     R1,R0,#+1
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0x9100             STR      R1,[SP, #+0]
   \   0000020C   0xD1FA             BNE.N    ??lcd_init_8
   \                     ??lcd_init_7: (+1)
   \   0000020E   0x.... 0x....      BL       IWDG_ReloadCounter
    163            lcd_write_control(0x01);  							// Clear Display  (Clear Display,Set DD RAM Address=0)
   \   00000212   0x2200             MOVS     R2,#+0
   \   00000214   0xF44F 0x5180      MOV      R1,#+4096
   \   00000218   0x4620             MOV      R0,R4
   \   0000021A   0x.... 0x....      BL       GPIO_WriteBit
   \   0000021E   0x2200             MOVS     R2,#+0
   \   00000220   0x2108             MOVS     R1,#+8
   \   00000222   0x4620             MOV      R0,R4
   \   00000224   0x.... 0x....      BL       GPIO_WriteBit
   \   00000228   0x2200             MOVS     R2,#+0
   \   0000022A   0x2104             MOVS     R1,#+4
   \   0000022C   0x4620             MOV      R0,R4
   \   0000022E   0x.... 0x....      BL       GPIO_WriteBit
   \   00000232   0x2200             MOVS     R2,#+0
   \   00000234   0x2102             MOVS     R1,#+2
   \   00000236   0x4620             MOV      R0,R4
   \   00000238   0x.... 0x....      BL       GPIO_WriteBit
   \   0000023C   0x2200             MOVS     R2,#+0
   \   0000023E   0x2101             MOVS     R1,#+1
   \   00000240   0x4620             MOV      R0,R4
   \   00000242   0x.... 0x....      BL       GPIO_WriteBit
   \   00000246   0x.... 0x....      BL       enable_lcd
   \   0000024A   0x2201             MOVS     R2,#+1
   \   0000024C   0x2108             MOVS     R1,#+8
   \   0000024E   0x4620             MOV      R0,R4
   \   00000250   0x.... 0x....      BL       GPIO_WriteBit
   \   00000254   0x2200             MOVS     R2,#+0
   \   00000256   0x2104             MOVS     R1,#+4
   \   00000258   0x4620             MOV      R0,R4
   \   0000025A   0x.... 0x....      BL       GPIO_WriteBit
   \   0000025E   0x2200             MOVS     R2,#+0
   \   00000260   0x2102             MOVS     R1,#+2
   \   00000262   0x4620             MOV      R0,R4
   \   00000264   0x.... 0x....      BL       GPIO_WriteBit
   \   00000268   0x2200             MOVS     R2,#+0
   \   0000026A   0x2101             MOVS     R1,#+1
   \   0000026C   0x4620             MOV      R0,R4
   \   0000026E   0x.... 0x....      BL       GPIO_WriteBit
   \   00000272   0x.... 0x....      BL       enable_lcd
   \   00000276   0x7830             LDRB     R0,[R6, #+0]
   \   00000278   0xB118             CBZ.N    R0,??lcd_init_9
   \   0000027A   0x2001             MOVS     R0,#+1
   \   0000027C   0x.... 0x....      BL       OS_Delay
   \   00000280   0xE006             B.N      ??lcd_init_10
   \                     ??lcd_init_9: (+1)
   \   00000282   0x2064             MOVS     R0,#+100
   \   00000284   0x9000             STR      R0,[SP, #+0]
   \                     ??lcd_init_11: (+1)
   \   00000286   0x9800             LDR      R0,[SP, #+0]
   \   00000288   0x1E41             SUBS     R1,R0,#+1
   \   0000028A   0x2800             CMP      R0,#+0
   \   0000028C   0x9100             STR      R1,[SP, #+0]
   \   0000028E   0xD1FA             BNE.N    ??lcd_init_11
   \                     ??lcd_init_10: (+1)
   \   00000290   0x.... 0x....      BL       IWDG_ReloadCounter
    164            //DelaymS(15);  										// Wait Command Ready
    165            //OS_Delay(15);
    166            DelayuS(15000);
   \   00000294   0x9500             STR      R5,[SP, #+0]
   \                     ??lcd_init_12: (+1)
   \   00000296   0x9800             LDR      R0,[SP, #+0]
   \   00000298   0x1E41             SUBS     R1,R0,#+1
   \   0000029A   0x2800             CMP      R0,#+0
   \   0000029C   0x9100             STR      R1,[SP, #+0]
   \   0000029E   0xD1FA             BNE.N    ??lcd_init_12
    167          }
   \   000002A0   0xB002             ADD      SP,SP,#+8
   \   000002A2   0xBD70             POP      {R4-R6,PC}       ;; return
    168          
    169          /***************************/
    170          /* Set LCD Position Cursor */
    171          /***************************/

   \                                 In section .text, align 2, keep-with-next
    172          void goto_cursor(unsigned char i)
    173          {
   \                     goto_cursor: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    174            i |= 0x80;											// Set DD-RAM Address Command
    175          #if defined (BOOTLOADER)
    176            lcd_write_control(i);
    177          #else
    178            OS_Use( &SemaLCD );
   \   00000004   0x....             LDR.N    R5,??DataTable10_3
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       OS_Use
    179            lcd_write_control(i);
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xF44F 0x5180      MOV      R1,#+4096
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011000
   \   00000016   0x.... 0x....      BL       GPIO_WriteBit
   \   0000001A   0xF044 0x0080      ORR      R0,R4,#0x80
   \   0000001E   0x.... 0x....      BL       lcd_write_byte
    180            OS_Unuse( &SemaLCD );
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0xB001             ADD      SP,SP,#+4
   \   00000026   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000002A   0x.... 0x....      B.W      OS_Unuse
    181          #endif
    182          }
    183          

   \                                 In section .text, align 2, keep-with-next
    184          void lcd_clear() {
   \                     lcd_clear: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    185          #if defined (BOOTLOADER)
    186             lcd_write_control(0x01);	// Clear Display
    187          #else
    188             OS_Use( &SemaLCD );
   \   00000002   0x....             LDR.N    R4,??DataTable10_3
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       OS_Use
    189             lcd_write_control(0x01);	// Clear Display
   \   0000000C   0x....             LDR.N    R5,??DataTable10  ;; 0x40011000
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xF44F 0x5180      MOV      R1,#+4096
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       GPIO_WriteBit
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2108             MOVS     R1,#+8
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       GPIO_WriteBit
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       GPIO_WriteBit
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       GPIO_WriteBit
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       GPIO_WriteBit
   \   00000042   0x.... 0x....      BL       enable_lcd
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x2108             MOVS     R1,#+8
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       GPIO_WriteBit
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x2104             MOVS     R1,#+4
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0x.... 0x....      BL       GPIO_WriteBit
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x2102             MOVS     R1,#+2
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x.... 0x....      BL       GPIO_WriteBit
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       GPIO_WriteBit
   \   0000006E   0x.... 0x....      BL       enable_lcd
   \   00000072   0x....             LDR.N    R0,??DataTable10_1
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0xB118             CBZ.N    R0,??lcd_clear_0
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x.... 0x....      BL       OS_Delay
   \   0000007E   0xE006             B.N      ??lcd_clear_1
   \                     ??lcd_clear_0: (+1)
   \   00000080   0x2064             MOVS     R0,#+100
   \   00000082   0x9000             STR      R0,[SP, #+0]
   \                     ??lcd_clear_2: (+1)
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x1E41             SUBS     R1,R0,#+1
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0x9100             STR      R1,[SP, #+0]
   \   0000008C   0xD1FA             BNE.N    ??lcd_clear_2
   \                     ??lcd_clear_1: (+1)
   \   0000008E   0x.... 0x....      BL       IWDG_ReloadCounter
    190             OS_Unuse( &SemaLCD );
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0xB001             ADD      SP,SP,#+4
   \   00000096   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000009A   0x.... 0x....      B.W      OS_Unuse
    191          #endif
    192          }
    193          
    194          /************************************/
    195          /* Print Display Data(ASCII) to LCD */
    196          /************************************/

   \                                 In section .text, align 2, keep-with-next
    197          void lcd_print( char* str )
    198          {
   \                     lcd_print: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    199            int i;
    200          #if !defined (BOOTLOADER)
    201            OS_Use( &SemaLCD );
   \   00000006   0x....             LDR.N    R5,??DataTable10_3
   \   00000008   0x....             LDR.N    R7,??DataTable10  ;; 0x40011000
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       OS_Use
    202          #endif
    203            for (i=0;i<16 && str[i]!=0;i++)  						// 16 Character Print
   \   00000010   0x2610             MOVS     R6,#+16
   \                     ??lcd_print_0: (+1)
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0xB160             CBZ.N    R0,??lcd_print_1
    204            {
    205              lcd_write_ascii(str[i]);							// Print Byte to LCD
   \   00000016   0xF814 0x8B01      LDRB     R8,[R4], #+1
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0xF44F 0x5180      MOV      R1,#+4096
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0x.... 0x....      BL       GPIO_WriteBit
   \   00000026   0x4640             MOV      R0,R8
   \   00000028   0x.... 0x....      BL       lcd_write_byte
    206            }
   \   0000002C   0x1E76             SUBS     R6,R6,#+1
   \   0000002E   0xD1F0             BNE.N    ??lcd_print_0
    207             goto_cursor( 0x00 );
   \                     ??lcd_print_1: (+1)
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       OS_Use
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0xF44F 0x5180      MOV      R1,#+4096
   \   0000003C   0x4638             MOV      R0,R7
   \   0000003E   0x.... 0x....      BL       GPIO_WriteBit
   \   00000042   0x2080             MOVS     R0,#+128
   \   00000044   0x.... 0x....      BL       lcd_write_byte
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       OS_Unuse
    208          #if !defined (BOOTLOADER)
    209             OS_Unuse( &SemaLCD );
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000054   0x.... 0x....      B.W      OS_Unuse
    210          #endif
    211          }
    212          
    213          /******************/
    214          /* Wait LCD Ready */
    215          /******************/
    216          

   \                                 In section .text, align 2, keep-with-next
    217          char busy_lcd(void)
    218          {
   \                     busy_lcd: (+1)
   \   00000000   0xB500             PUSH     {LR}
    219          #if !defined (BOOTLOADER)
    220             if ( OS_IsRunning() ) {
   \   00000002   0x....             LDR.N    R0,??DataTable10_1
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB118             CBZ.N    R0,??busy_lcd_0
    221                OS_Delay (1);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       OS_Delay
   \   00000010   0xE006             B.N      ??busy_lcd_1
    222             } else {
    223                DelayuS(100);
   \                     ??busy_lcd_0: (+1)
   \   00000012   0x2064             MOVS     R0,#+100
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \                     ??busy_lcd_2: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x1E41             SUBS     R1,R0,#+1
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0x9100             STR      R1,[SP, #+0]
   \   0000001E   0xD1FA             BNE.N    ??busy_lcd_2
    224             }
    225             IWDG_ReloadCounter();
   \                     ??busy_lcd_1: (+1)
   \   00000020   0x.... 0x....      BL       IWDG_ReloadCounter
    226          #else
    227             DelayuS( 1000 );
    228          #endif
    229             return 0;											// LCD Busy Status
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0xBD00             POP      {PC}             ;; return
    230          
    231          #if 0
    232            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		// Config D7 = Read
    233            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    234            GPIO_InitStructure.GPIO_Pin = LCD_D7_PIN;
    235            GPIO_Init((GPIO_TypeDef*)LCD_DATA_PORT, &GPIO_InitStructure);
    236          
    237            LCD_RS_LO();		 									// Instruction Select
    238            LCD_RW_HI(); 											// Read Direction
    239            LCD_EN_HI();											// Start Read Busy
    240          
    241            DelayuS(100);
    242            //OS_Delay (1);
    243            // Delay Before Read
    244            if (GPIO_ReadInputDataBit((GPIO_TypeDef*)LCD_DATA_PORT, LCD_D7_PIN) == Bit_SET)
    245            {
    246              LCD_EN_LO();  										// Disable Read
    247            	LCD_RW_LO();										// Default = Write Direction
    248          
    249          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  	// Config D7 = Write
    250              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    251              GPIO_InitStructure.GPIO_Pin = LCD_D7_PIN;
    252              GPIO_Init((GPIO_TypeDef*)LCD_DATA_PORT, &GPIO_InitStructure);
    253              return 1;											// LCD Busy Status
    254            }
    255            else
    256            {
    257              LCD_EN_LO();  										// Disable Read
    258            	LCD_RW_LO();										// Default = Write Direction
    259          
    260          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	// Config D7 = Write
    261              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    262              GPIO_InitStructure.GPIO_Pin = LCD_D7_PIN;
    263              GPIO_Init((GPIO_TypeDef*)LCD_DATA_PORT, &GPIO_InitStructure);
    264              return 0;											// LCD Ready Status
    265            }
    266          #endif  
    267          }
    268          
    269          
    270          /***********************/
    271          /* Enable Pulse to LCD */
    272          /***********************/

   \                                 In section .text, align 2, keep-with-next
    273          void enable_lcd(void)	 								// Enable Pulse
    274          {
   \                     enable_lcd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    275            LCD_EN_HI();  										// Enable ON
   \   00000002   0x....             LDR.N    R4,??DataTable10  ;; 0x40011000
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF44F 0x6180      MOV      R1,#+1024
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       GPIO_WriteBit
    276            DelayuS(50);
   \   00000012   0x2032             MOVS     R0,#+50
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \                     ??enable_lcd_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x1E41             SUBS     R1,R0,#+1
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0x9100             STR      R1,[SP, #+0]
   \   0000001E   0xD1FA             BNE.N    ??enable_lcd_0
    277            //OS_Delay(1);
    278            LCD_EN_LO();  										// Enable OFF
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xB002             ADD      SP,SP,#+8
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0xF44F 0x6180      MOV      R1,#+1024
   \   0000002E   0x.... 0x....      B.W      GPIO_WriteBit
    279          }
    280          
    281          /*******************************************************************************
    282          * Function Name  : Delay
    283          * Description    : Inserts a delay time.
    284          * Input          : nCount: specifies the delay time length.
    285          * Output         : None
    286          * Return         : None
    287          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    288          void DelayuS(vu32 nCount)
    289          {
   \                     DelayuS: (+1)
   \   00000000   0xB401             PUSH     {R0}
    290            while (nCount--);
   \                     ??DelayuS_0: (+1)
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x1E41             SUBS     R1,R0,#+1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0x9100             STR      R1,[SP, #+0]
   \   0000000A   0xD1FA             BNE.N    ??DelayuS_0
    291          }
   \   0000000C   0xB001             ADD      SP,SP,#+4
   \   0000000E   0x4770             BX       LR               ;; return
    292          
    293          #if 0
    294          /*******************************************************************************
    295          * Function Name  : Delay
    296          * Description    : Inserts a delay time.
    297          * Input          : nTime: specifies the delay time length, in milliseconds.
    298          * Output         : None
    299          * Return         : None
    300          *******************************************************************************/
    301          void DelaymS(u32 nTime)
    302          {
    303            /* Enable the SysTick Counter */
    304            SysTick_CounterCmd(SysTick_Counter_Enable);
    305          
    306            TimingDelay = nTime;
    307          
    308            while(TimingDelay != 0);
    309          
    310            /* Disable SysTick Counter */
    311            SysTick_CounterCmd(SysTick_Counter_Disable);
    312            /* Clear SysTick Counter */
    313            SysTick_CounterCmd(SysTick_Counter_Clear);
    314          }
    315          #endif
    316          
    317          #if 1
    318          /*******************************************************************************
    319          * Function Name  : TimingDelay_Decrement
    320          * Description    : Decrements the TimingDelay variable.
    321          * Input          : None
    322          * Output         : TimingDelay
    323          * Return         : None
    324          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    325          void TimingDelay_Decrement(void)
    326          {
    327            if (TimingDelay != 0x00)
   \                     TimingDelay_Decrement: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_4
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xB111             CBZ.N    R1,??TimingDelay_Decrement_0
    328            {
    329              TimingDelay--;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    330            }
    331          }
   \                     ??TimingDelay_Decrement_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OS_Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     GPIO_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     SemaLCD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     TimingDelay
    332          
    333          #if  0
    334          /*******************************************************************************
    335          * Function Name  : assert_failed
    336          * Description    : Reports the name of the source file and the source line number
    337          *                  where the assert_param error has occurred.
    338          * Input          : - file: pointer to the source file name
    339          *                  - line: assert_param error line source number
    340          * Output         : None
    341          * Return         : None
    342          *******************************************************************************/
    343          void assert_failed(u8* file, u32 line)
    344          {
    345            /* User can add his own implementation to report the file name and line number,
    346               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    347          
    348            /* Infinite loop */
    349            while (1)
    350            {
    351            }
    352          }
    353          #endif
    354          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   DelayuS
       0   TimingDelay_Decrement
       8   busy_lcd
         8   -> IWDG_ReloadCounter
         8   -> OS_Delay
      16   enable_lcd
         0   -> GPIO_WriteBit
        16   -> GPIO_WriteBit
      16   goto_cursor
        16   -> GPIO_WriteBit
         0   -> OS_Unuse
        16   -> OS_Use
        16   -> lcd_write_byte
      16   lcd_clear
        16   -> GPIO_WriteBit
        16   -> IWDG_ReloadCounter
        16   -> OS_Delay
         0   -> OS_Unuse
        16   -> OS_Use
        16   -> enable_lcd
      24   lcd_init
        24   -> GPIO_Init
        24   -> GPIO_WriteBit
        24   -> IWDG_ReloadCounter
        24   -> OS_Delay
        24   -> RCC_APB2PeriphClockCmd
        24   -> enable_lcd
        24   -> lcd_out_data4
        24   -> lcd_write_byte
      16   lcd_out_data4
         0   -> GPIO_WriteBit
        16   -> GPIO_WriteBit
      24   lcd_print
        24   -> GPIO_WriteBit
         0   -> OS_Unuse
        24   -> OS_Unuse
        24   -> OS_Use
        24   -> lcd_write_byte
       8   lcd_write_ascii
         8   -> GPIO_WriteBit
         0   -> lcd_write_byte
      16   lcd_write_byte
         0   -> IWDG_ReloadCounter
        16   -> OS_Delay
        16   -> enable_lcd
        16   -> lcd_out_data4
       8   lcd_write_control
         8   -> GPIO_WriteBit
         0   -> lcd_write_byte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
      16  DelayuS
      16  SemaLCD
       4  TimingDelay
      14  TimingDelay_Decrement
      42  busy_lcd
      50  enable_lcd
      46  goto_cursor
     158  lcd_clear
     676  lcd_init
      82  lcd_out_data4
      88  lcd_print
      26  lcd_write_ascii
      68  lcd_write_byte
      26  lcd_write_control

 
    20 bytes in section .bss
 1 312 bytes in section .text
 
 1 312 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
